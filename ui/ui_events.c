// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.6
// Project name: SquareLine_Project

// 很明显, 有许多鬼命名, 多亏了squareline导出的代码的格式与我代码风格的冲突

#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
#include <freertos/task.h>
#include <locale.h>
#include <nvs.h>
#include "nvs_flash.h"
#include <stdio.h>
#include <time.h>

#include "backlight.h"
#include "bluetooth.h"
#include "driver/uart.h"

#include "ui.h"
#include "ui_comp_music_item.h"
#include "wifi.h"
#include "rs485.h"

//////////////////// DEFINITIONS ////////////////////
#define MAX_ITEMS_PER_LIST 5                        // 每个MusicList里有几首歌
#define MAX_LISTS 10                                // 假设最多有 10 个 MusicList
#define INACTIVE_TIME 0.5 * 60 * 1000               // 无操作几分钟就返回主界面的几
#define MAX_VOLUME_LIMIT 30                         // 真实的音量上限
#define ENTER_SETTINGS_WINDOW_CLICK_COUNT 5         // 进入设置界面需要点击的次数
#define ENTER_SETTINGS_WINDOW_CLICK_RESET_TIME 500  // 进入设置界面点击的间隔, 每两次点击间隔不能超过500ms

//////////////////// GLOBAL VARIABLES ////////////////////

static lv_obj_t *musicLists[MAX_LISTS]; // 存储 MusicList 的指针数组
static int currentListIndex = 0;        // 当前 MusicList 的索引
static int numMusicLists = 0;           // MusicList 的总数

static bool playing = false;            // 播放状态
static lv_timer_t *progressTimer = NULL;// 音频进度条定时器
static int currentPlayTime = 0;         // 音频进度条的当前值

static lv_obj_t **music_obj_list = NULL;    // 储存所有歌的MusicItem对象, 用于实习当前播放高亮
static lv_obj_t *current_playing_music_obj; // 当前歌的MusicItem对象, 同样用于实现当前播放高亮

static lv_timer_t *inactive_timer;       // 不活动就返回主界面, 的定时器
static lv_timer_t *close_tf_card_notfound_msg_timer;    // 用来关闭"tf卡不存在"弹窗的定时器

// 蓝牙名称与密码
char *bluetooth_ui_name = NULL;
char *bluetooth_ui_pass = NULL;

// 当前音量
int current_volume;
// 默认音量与最大音量
uint32_t defaultVolume = 8;
uint32_t maxVolume = 15;
// 调节音量时的防抖定时器
static TimerHandle_t volume_timer = NULL;

// ID
uint32_t system_id = 0;


// 当前页面的音量显示和音量调节块的指针, 写得好恶心.
// 还有从熄屏中醒来的点击范围
lv_obj_t * current_screen_header_volume = NULL;
lv_obj_t * current_screen_volume_component = NULL;
lv_obj_t * current_screen_on_screen_range = NULL;

// 播放模式部分
int shuffle_list_index = 0;  // 当前播放的歌曲的index, 在洗牌数组里的索引
typedef enum {
    PLAY_MODE_LOOP,
    PLAY_MODE_SINGLE,
    PLAY_MODE_SHUFFLE,
} play_mode_t;

play_mode_t play_mode = PLAY_MODE_LOOP;  // 默认循环播放模式
int *shuffle_order;                      // 用于随机播放模式的洗牌数组

// 均衡器
typedef enum {
    EQ_MODE_NATURE,     // 自然
    EQ_MODE_JAZZ,       // 爵士
    EQ_MODE_ROCK,       // 摇滚
    EQ_MODE_POP,        // 流行
    EQ_MODE_CLASSICAL,  // 古典
    EQ_MODE_OPERA       // 歌剧
} equalizer_t;

equalizer_t equalizer_mode = EQ_MODE_POP;


// TaskHandle_t music_play_mode_task_handle = NULL;     // 这两个放在rs485.h声明了, 好惨
// TaskHandle_t nature_play_task_handle = NULL;
static TaskHandle_t bluetooth_monitor_state_task_handle = NULL;
static TaskHandle_t wait_wifi_connect_task_handle = NULL;

static char **file_names = NULL;
static uint32_t *music_durations = NULL;

// 开机初始化阶段会有某些地方争着发AT指令, 所以用个信号量
SemaphoreHandle_t init_phase_semaphore = NULL;

static bool create_music_item_complete = false;     // 如果已插入卡, 但是没有刷新音乐列表就进音乐库什么的会出事

//////////////////// STATIC FUNCTION DECLARATIONS ////////////////////
// 真有必要写这些吗

static void format_time(int seconds, char *buffer, size_t buffer_size);
static void update_progress(lv_timer_t *timer);
static void initProgressBar(void);
static void bluetooth_cfg_task(void *pvParameter);
static time_t convertToTimestamp(uint32_t year, uint32_t month, uint32_t day, uint32_t hour, uint32_t min);
static void inactive_callback(lv_timer_t *timer);
static void bluetooth_monitor_state_task(void *pvParameter);
static void changeMusicUpdateUI(void);
static void update_header_volume(void);
static void shufflePlaylist(void);
static void music_play_mode_task(void *pvParameter);
static void bluetooth_cfg_task(void *pvParameter);
static void bluetooth_sync_cfg(void);
static void selectNatureSoundTask(void *pvParameter);
static void close_tf_card_notfound_msg_timer_callback(lv_timer_t *timer);
//////////////////// 不给lvgl事件直接调用的静态函数 ////////////////////

// 创建Music List及item
static void create_music_item(void) {
    // 从nvs中读取所有音乐文件名储存于file_names
    nvs_handle_t nvs_handle;
    esp_err_t err;

    err = nvs_open("filenames", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("create_music_item", "NVS中未找到filenames命名空间, 需要刷新");
        return;
    }

    // 读取字符串数量
    err = nvs_get_u32(nvs_handle, "music_count", &music_files_count);
    if (err != ESP_OK) {
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_get_u32(nvs_handle, "bath_count", &bath_files_count);
    if (err != ESP_OK) {
        nvs_close(nvs_handle);
        return;
    }

    // 读取字符串们
    file_names = (char **)malloc((music_files_count + bath_files_count + 4) * sizeof(char *));
    if (file_names == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory for file_names");
        nvs_close(nvs_handle);
        return;
    }
    for (int i = 0; i < music_files_count + bath_files_count + 4; i++) {
        char key[16];
        snprintf(key, sizeof(key), "file_%u", (unsigned int)i);

        // 获取字符串长度
        size_t required_size;
        err = nvs_get_str(nvs_handle, key, NULL, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("create_music_item", "Failed to nvs_get_str required_size: [%d]", i);
            for (size_t j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }
        
        file_names[i] = malloc(required_size);
        if (file_names[i] == NULL) {
            ESP_LOGE("create_music_item", "Failed to allocate memory for file_names[%d]", i);
            for (int j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }

        err = nvs_get_str(nvs_handle, key, file_names[i], &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("create_music_item", "Failed to nvs_get_str: [%d]", i);
            for (size_t j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }
    }
    nvs_close(nvs_handle);

    music_obj_list = (lv_obj_t **)malloc(music_files_count * sizeof(lv_obj_t *));
    if (music_obj_list == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory for music_obj_list");
        return;
    }

    // 生成列表UI
    musicLists[currentListIndex] = ui_Music_List_create(ui_Music_List_Container);
    numMusicLists++;
    int items_added = 0;
    for (int i = 0; i < music_files_count; i++) {
        // 如果当前列表的 Music_item 数量达到最大值，切换到下一个列表
        if (items_added >= MAX_ITEMS_PER_LIST) {
            currentListIndex++;
            if (currentListIndex >= MAX_LISTS) {
                ESP_LOGE("create_music_item_task", "Exceeded maximum number of lists");
                break;
            }
            // 创建新的 MusicList
            musicLists[currentListIndex] = ui_Music_List_create(ui_Music_List_Container);
            numMusicLists++;
            lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
            items_added = 0;  // 重置计数器
        }
        // 创建musicItem
        lv_obj_t *obj = ui_Music_Item_create(musicLists[currentListIndex]);

        lv_obj_t *icon = lv_obj_get_child(obj, 2);
        lv_img_set_src(icon, &ui_img_35201459);

        lv_obj_t *name_label = lv_obj_get_child(obj, 0);
        lv_label_set_text(name_label, file_names[i] + 2);

        music_obj_list[i] = obj;

        items_added++;
    }
    // 将当前显示的设置为第一个列表
    currentListIndex = 0;
    // 顺便初始化一下进度条
    initProgressBar();

    // 显示正常的tf卡图标(把X隐藏掉)
    lv_obj_add_flag(ui_tfcard_unavailable_the_X, LV_OBJ_FLAG_HIDDEN);

    // 收集bath里的歌的id
    bath_file_ids = (int *)malloc(bath_files_count * sizeof(int));
    if (bath_file_ids == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory");
        return;
    }
    for (int i = 0; i < bath_files_count; i++) {
        // 提取id
        char id_str[3] = { file_names[music_files_count + i][0], file_names[music_files_count + i][1], '\0' };
        bath_file_ids[i] = atoi(id_str);
    }

    create_music_item_complete = true;
}
static void init_durations_for_nvs(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err;

    err = nvs_open("music_durations", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("init_durations_for_nvs", "NVS中未找到music_durations命名空间, 需要刷新");
        return;
    }

    // 读取duration们
    music_durations = (uint32_t *)malloc(music_files_count * sizeof(uint32_t));
    if (music_durations == NULL) {
        ESP_LOGE("init_durations_for_nvs", "Failed to allocate memory for music_durations");
        nvs_close(nvs_handle);
        return;
    }
    for (int i = 0; i < music_files_count; i++) {
        char key[16];
        snprintf(key, sizeof(key), "file_%u", (unsigned int)i);

        err = nvs_get_u32(nvs_handle, key, &music_durations[i]);
        if (err != ESP_OK) {
            ESP_LOGE("init_durations_for_nvs", "Failed to music_duration: [%d]", i);
            free(music_durations);
            nvs_close(nvs_handle);
            return;
        }
    }
    nvs_close(nvs_handle);
}
// 将秒转为hh:mm:ss
static void format_time(int seconds, char *buffer, size_t buffer_size) {
    int hours = seconds / 3600;
    int minutes = (seconds % 3600) / 60;
    int sec = seconds % 60;
    int ret = snprintf(buffer, buffer_size, "%02d:%02d:%02d", hours, minutes, sec);

    // 检查 snprintf 是否成功
    if (ret < 0 || ret >= buffer_size) {
        // 错误处理：确保缓冲区以 null 结尾
        if (buffer_size > 0) {
            buffer[0] = '\0';
        }
        fprintf(stderr, "Error formatting time string\n");
    }
}

// 时间转为时间戳
static time_t convertToTimestamp(uint32_t year, uint32_t month, uint32_t day, uint32_t hour, uint32_t min) {
    struct tm timeinfo;

    // 初始化 struct tm 结构
    timeinfo.tm_year = year - 1900;  // tm_year 从 1900 年开始计算
    timeinfo.tm_mon = month - 1;     // tm_mon 是从 0 到 11，所以减 1
    timeinfo.tm_mday = day;
    timeinfo.tm_hour = hour;  // 8小时时区
    timeinfo.tm_min = min;
    timeinfo.tm_sec = 0;
    timeinfo.tm_isdst = -1;  // 自动判断是否是夏令时

    // 将 struct tm 结构转换为时间戳
    time_t timestamp = mktime(&timeinfo);

    // 返回时间戳
    return timestamp;
}
// 当退出蓝牙界面时, 需要关闭一堆东西
static void cleanBluetoothTask(void *pvParameter) {
    // 进入空闲模式
    bluetooth_send_at_command("AT+CM0", CMD_CHANGE_TO_IDLE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_IDLE, pdTRUE, pdFALSE, portMAX_DELAY);
    work_mode = 0;
    bluetooth_send_at_command("AT+CL0", CMD_CHANGE_CHANNEL);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_CHANNEL, pdTRUE, pdFALSE, portMAX_DELAY);
    // 关闭提示音以防止进音乐模式时播放"tf卡模式"
    bluetooth_send_at_command("AT+CN1", CMD_CHANGE_PROMPT_TONE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_PROMPT_TONE, pdTRUE, pdFALSE, portMAX_DELAY);
    // 删除蓝牙状态监听任务
    if (bluetooth_monitor_state_task_handle != NULL) {
        vTaskDelete(bluetooth_monitor_state_task_handle);
        bluetooth_monitor_state_task_handle = NULL;
    }
    // 删除浴室播放任务
    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
    }
    vTaskDelete(NULL);
}
// 不活动定时器的回调, 在非main界面无操作一定时间后, 从xx界面回到main界面
static void inactive_callback(lv_timer_t *timer) {
    // 记录当前screen
    // lv_obj_t *prevScreen = lv_scr_act();
    // 关闭当前页的音量调节块
    closeVolumeAdjust(NULL);
    lv_scr_load(ui_Main_Window);

    // del_inactive_timer();  不在这写这个, 而是放在mainScrLoaded, 因为主动返回主界面也要停止这个timer
}
// 创建不活动定时器
void create_inactive_timer(void) {
    if (inactive_timer == NULL) {
        inactive_timer = lv_timer_create(inactive_callback, INACTIVE_TIME, NULL);
    }
}
// 删除不活动定时器
void del_inactive_timer(void) {
    if (inactive_timer != NULL) {
        lv_timer_del(inactive_timer);
        inactive_timer = NULL;
    }
}
// 重置不活动定时器
void reset_inactive_timer(void) {
    if (inactive_timer != NULL) {
        lv_timer_reset(inactive_timer);
    }
}
// 感觉很危险的极性状态机
static void bluetooth_monitor_state_task(void *pvParameter) {
    while (1) {
        if (bluetooth_state == 2) {
            printf("蓝牙已连接\n");
            del_inactive_timer();
            // 等待断开事件
            xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_DISCONNECTED, pdTRUE, pdFALSE, portMAX_DELAY);
        } else if (bluetooth_state == 1) {
            printf("等待连接中\n");
            create_inactive_timer();
            // 等待连接事件
            xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_CONNECTED, pdTRUE, pdFALSE, portMAX_DELAY);
        }
    }
}
// 更新当前界面的音量显示
static void update_header_volume(void) {
    lv_label_set_text_fmt(lv_obj_get_child(current_screen_header_volume, 1), "%d", current_volume);
    lv_slider_set_value(lv_obj_get_child(current_screen_volume_component, 0), current_volume * 2 * MAX_VOLUME_LIMIT / maxVolume, LV_ANIM_OFF);
}
// 洗牌
static void shufflePlaylist(void) {
    if (shuffle_order == NULL) {
        shuffle_order = malloc(music_files_count * sizeof(int));
    }

    for (int i = 0; i < music_files_count; i++) {
        shuffle_order[i] = i;
    }
    for (int i = music_files_count - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int temp = shuffle_order[i];
        shuffle_order[i] = shuffle_order[j];
        shuffle_order[j] = temp;
    }
    printf("shuffle: ");
    for (int i = 0; i < music_files_count; i++) {
        printf("%d, ", shuffle_order[i]);
    }
    printf("\b\n");
}
// 下一首, 上一首, 点击列表播放之类的, 同样需要做的UI更新
static void changeMusicUpdateUI(void) {
    // 暂停定时器
    lv_timer_pause(progressTimer);
    // 重置进度条
    lv_bar_set_value(ui_Progress_Slider, 0, LV_ANIM_OFF);
    lv_label_set_text(ui_Current_Time, "00:00:00");
    lv_label_set_text(ui_Total_Time, "00:00:00");

    playing = true;
    lv_img_set_src(ui_Play_Pause_Icon, &ui_img_899744137);
}
// 当播放完毕后下一首的任务
static void music_play_mode_task(void *pvParameter) {
    while (1) {
        xEventGroupWaitBits(bt_event_group, EVENT_END_PLAY, pdTRUE, pdFALSE, portMAX_DELAY);
        nextTrack(NULL);
    }
}
// 什么b命名?
static void close_tf_card_notfound_msg_timer_callback_callback(void *Param) {
    lv_obj_add_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
}
// 关闭"tf卡未插入"的弹窗的回调
static void close_tf_card_notfound_msg_timer_callback(lv_timer_t *timer) {
    lv_async_call(close_tf_card_notfound_msg_timer_callback_callback, NULL);
}

//////////////////// lvgl事件回调 ////////////////////

// ******************** initial actions ********************

// 除了这个, 还有各个init[****]Settings函数也在initital actions
void initActions(lv_event_t *e) {
    // 等待上电的主动返回值被丢掉
    xEventGroupWaitBits(bt_event_group, EVENT_STARTUP_SUCCESS, pdTRUE, pdFALSE, portMAX_DELAY);

    inactive_timer = lv_timer_create(inactive_callback, INACTIVE_TIME, NULL);
    lv_timer_pause(inactive_timer);
    close_tf_card_notfound_msg_timer = lv_timer_create(close_tf_card_notfound_msg_timer_callback, 2000, NULL);

    init_phase_semaphore = xSemaphoreCreateBinary();
    if (init_phase_semaphore == NULL) {
        ESP_LOGE("initActions", "创建信号量失败");
    }
    // 查询设备状态
    bluetooth_send_at_command("AT+MV", CMD_GET_DEVICE_STATE);
    xEventGroupWaitBits(bt_event_group, EVENT_GET_DEVICE_STATE, pdTRUE, pdFALSE, portMAX_DELAY);
    // 关闭提示音
    bluetooth_send_at_command("AT+CN1", CMD_CHANGE_PROMPT_TONE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_PROMPT_TONE, pdTRUE, pdFALSE, portMAX_DELAY);

    xSemaphoreGive(init_phase_semaphore);

    if (device_state == 2) {
        // 初始化音乐列表和durations
        create_music_item();
        init_durations_for_nvs();
    } else {
        ESP_LOGW("initActions", "未识别到TF卡");
    }

    // 设置待机界面的日期label, 只能写在这了, 毕竟日期就这个地方会显示
    set_date_label(ui_Idle_Window_Date);
    // 设置待机screen, 为了不让多余的文件include "ui_events.h"只好这么写了
    idle_window = ui_Idle_Window;
}

// ******************** 各界面加载完成后的回调 ********************
// 各个screen loaded时, 将screen的时间label设置为time_label上, 保持全局时间显示, Settings界面没有这东西

void mainScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Main_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Main_Header_Volume;
    current_screen_volume_component = ui_Main_Window_Volume_adjust;
    current_screen_on_screen_range = ui_On_Main_Screen_Range;
    update_header_volume();

    // 每次到主界面时, 重建一个背光定时器, 因为只有在主界面时才会进入待机模式
    init_backlight_timer(backlight_time_level_to_second(backlight_time_level));
    // 停止inactive定时器
    del_inactive_timer();
}
void musicScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Music_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Music_Header_Volume;
    current_screen_volume_component = ui_Music_Window_Volume_adjust;
    current_screen_on_screen_range = ui_Music_On_Screen_Range;
    update_header_volume();

    // 许多东西都不能写这里, 因为play界面也能进入music界面, 不知可以从main进入music, 所以许多东西要写在leaveMainWindow里
}
void musicPlayScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Music_Time2);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Music_Play_Header_Volume;
    current_screen_volume_component = ui_Music_Play_Window_Volume_adjust;
    current_screen_on_screen_range = ui_Music_Play_On_Screen_Range;
    update_header_volume();
}
void natureSoundScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Nature_Sound_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Nature_Header_Volume;
    current_screen_volume_component = ui_Nature_Window_Volume_adjust;
    update_header_volume();
}
void bluetoothScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Bluetooth_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Bluetooth_Header_Volume;
    current_screen_volume_component = ui_Bluetooth_Window_Volume_adjust;
    update_header_volume();

    // 进入蓝牙模式, 需要播放提示音
    open_living_room_channel();
    bluetooth_send_at_command("AT+CN0", CMD_CHANGE_PROMPT_TONE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_PROMPT_TONE, pdTRUE, pdFALSE, portMAX_DELAY);
    bluetooth_send_at_command("AT+CM1", CMD_CHANGE_TO_BLUETOOTH);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_BLUETOOTH, pdTRUE, pdFALSE, portMAX_DELAY);
    work_mode = 1;
    bluetooth_state = 1;    // 等待连接

    // 开启任务, 监听蓝牙
    if (bluetooth_monitor_state_task_handle == NULL) {
        xTaskCreate(bluetooth_monitor_state_task, "bluetooth_monitor_state_task", 4096, NULL, 5,
                    &bluetooth_monitor_state_task_handle);
    } else {
        ESP_LOGE("bluetoothScrLoaded", "这不可能");
    }
}
void modeScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Mode_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Mode_Header_Volume;
    current_screen_volume_component = ui_Mode_Window_Volume_adjust;
    update_header_volume();
}
void wakeupScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Wake_up_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Wakeup_Header_Volume;
    current_screen_volume_component = ui_Wakeup_Window_Volume_adjust;
    update_header_volume();
}
void guideScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Guide_Time);
    if (global_time > 0) update_current_time_label();
    current_screen_header_volume = ui_Guide_Header_Volume;
    current_screen_volume_component = ui_Guide_Window_Volume_adjust;
    update_header_volume();

    // 指南界面时, 不进入待机状态, 所以停止定时器
    // ...
}
void idleScrLoaded(lv_event_t *e) {
    set_time_label(ui_Idle_Window_Time);
    if (global_time > 0) update_current_time_label();
}
void settingsScrLoaded(lv_event_t *e) {

}
// ******************** 离开各界面后的回调 ********************

void leaveMainWindow(lv_event_t *e) {
    printf("Leave Main\n");
    // 关闭背光定时器, 因为只有处于主界面时才会试图定时以进入待机界面
    stop_backlight_timer();

    closeVolumeAdjust(NULL);
    // 处理特殊界面
    lv_obj_t *new_scr = lv_scr_act();
    // 进入Idle界面即正常待机
    if (new_scr == ui_Idle_Window) {
        printf("is Idle\n");
    }
    // 只有从main进入music界面才打开某些东西(因为play界面也能进入music界面)
    else if (new_scr == ui_Music_Window) {
        bluetooth_send_at_command("AT+CM2", CMD_CHANGE_TO_MUSIC);
        xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_MUSIC, pdTRUE, pdFALSE, portMAX_DELAY);
        work_mode = 2;

        assert(music_play_task_handle == NULL);
        xTaskCreate(music_play_mode_task, "music_play_mode_task", 4096, NULL, 5, &music_play_task_handle);
        if (bath_play_task_handle != NULL) {
            bluetooth_send_at_command("AT+AA0", CMD_STOP_TRACK);
            xEventGroupWaitBits(music_event_group, EVENT_STOP_TRACK, pdTRUE, pdFALSE, portMAX_DELAY);
            vTaskDelete(bath_play_task_handle);
            bath_play_task_handle = NULL;
        }
    }
    // 自然之音只是打开音乐模式
    else if (new_scr == ui_Nature_Sound_Window) {
        bluetooth_send_at_command("AT+CM2", CMD_CHANGE_TO_MUSIC);
        xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_MUSIC, pdTRUE, pdFALSE, portMAX_DELAY);
        work_mode = 2;
        create_inactive_timer();
    }
    // 设置界面不创建不活动定时器
    else if (new_scr == ui_Settings_Window) {

    }
    // 通常都创建不活动定时器, 无操作一定时间后回到主界面
    else {
        printf("别的界面, 创建活动定时器\n");
        create_inactive_timer();
    }
}
void leaveMusicWindow(lv_event_t *e) {
    printf("Leave Music\n");
    lv_obj_t *currentScreen = lv_scr_act();
    // 只有从music界面离开至main界面才关闭功放与停止音乐(因为music界面也能进入play界面)
    if (currentScreen == ui_Main_Window) {
        assert(music_play_task_handle != NULL);
        vTaskDelete(music_play_task_handle);
        music_play_task_handle = NULL;

        ESP_LOGI("leaveMusicWindow", "退出音乐库, 关闭功放, 退出音乐模式");
        bluetooth_send_at_command("AT+CL0", CMD_CHANGE_CHANNEL);
        xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_CHANNEL, pdTRUE, pdFALSE, portMAX_DELAY);
        bluetooth_send_at_command("AT+CM0", CMD_CHANGE_TO_IDLE);
        xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_IDLE, pdTRUE, pdFALSE, portMAX_DELAY);
        work_mode = 0;

        lv_timer_pause(progressTimer);

        // 关闭当前音乐名高亮
        if (current_playing_music_obj != NULL) {
            lv_obj_clear_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
            current_playing_music_obj = NULL;
        }
    }
}
void leaveMusicPlayWindow(lv_event_t * e) {
    printf("Leave Music Play\n");
}
void leaveNatureSoundWindow(lv_event_t *e) {
    printf("Leave Nature\n");
    // 主动或自动退出自然之音界面时, 关闭功放并进入空闲模式
    bluetooth_send_at_command("AT+CL0", CMD_CHANGE_CHANNEL);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_CHANNEL, pdTRUE, pdFALSE, portMAX_DELAY);
    bluetooth_send_at_command("AT+CM0", CMD_CHANGE_TO_IDLE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_IDLE, pdTRUE, pdFALSE, portMAX_DELAY);
    work_mode = 0;

    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }

    // 图标恢复
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);
}
void leaveBlutoothWindow(lv_event_t *e) { 
    xTaskCreate(cleanBluetoothTask, "cleanBluetoothTask", 4096, NULL, 5, NULL);
}
void leaveModeWindow(lv_event_t *e) {

}
void leaveWakeupWindow(lv_event_t *e) {

}
void leaveGuideWindow(lv_event_t *e) {

}
void leaveSettingsWindow(lv_event_t *e) {
    lv_obj_add_flag(ui_Volume_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_Backlight_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_System_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
}
// ******************** 背光相关 ********************

// 初始化背光亮度与时间, 以及创建进入待机的定时器
void initBacklightSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to open NVS");
        return;
    }

    err = nvs_get_u32(nvs_handle, "level", &backlight_level);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("backlightSettings", "NVS中未找到'level', 将写入默认值 %ld", backlight_level);
        err = nvs_set_u32(nvs_handle, "level", backlight_level);
        if (err != ESP_OK) {
            ESP_LOGE("backlightSettings", "Failed to set default value for 'level': %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to get 'level' from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);

    err = nvs_get_u32(nvs_handle, "time", &backlight_time_level);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("backlightSettings", "NVS中未找到'time'，将写入默认值 %ld", backlight_time_level);
        err = nvs_set_u32(nvs_handle, "time", backlight_time_level);
        if (err != ESP_OK) {
            ESP_LOGE("backlightSettings", "Failed to set default value for 'time': %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to get 'time' from NVS: %s", esp_err_to_name(err));
    }
    // 麻烦的off, 这行就像lv_label_set_text_fmt的用处
    set_backlight_time_to_label(ui_Backlight_Time_Value, backlight_time_level);
    nvs_close(nvs_handle);
}
// 确认保存背光设置
void saveBacklightSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to open NVS");
        return;
    }

    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    backlight_level = atoi(text);
    err = nvs_set_u32(nvs_handle, "level", backlight_level);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to set backlight_level in NVS");
        nvs_close(nvs_handle);
        return;
    }

    const char *second = lv_label_get_text(ui_Backlight_Time_Value);
    backlight_time_level = backlight_time_second_to_level(atoi(second));

    err = nvs_set_u32(nvs_handle, "time", backlight_time_level);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightTime", "Failed to set backlightTime in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
}
// 取消保存背光设置
void cancelSaveBacklightSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);
    set_backlight(backlight_level);
    set_backlight_time_to_label(ui_Backlight_Time_Value, backlight_time_level);
}
// 增加背光亮度
void addBrightness(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    int brightnessLevel = atoi(text);
    brightnessLevel = (brightnessLevel < 5) ? brightnessLevel + 1 : 5;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%d", brightnessLevel);
    set_backlight(brightnessLevel);
}
// 减少背光亮度
void decBrightness(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    int brightnessLevel = atoi(text);
    brightnessLevel = (brightnessLevel > 1) ? brightnessLevel - 1 : 1;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%d", brightnessLevel);
    set_backlight(brightnessLevel);
}
// 增加背光时间
void addBacklightTime(lv_event_t *e) {
    const char *second = lv_label_get_text(ui_Backlight_Time_Value);
    int backlightTimeLevel = backlight_time_second_to_level(atoi(second));

    if (backlightTimeLevel < 6) backlightTimeLevel++;

    set_backlight_time_to_label(ui_Backlight_Time_Value, backlightTimeLevel);
}
// 减少背光时间
void decBacklightTime(lv_event_t *e) {
    const char *second = lv_label_get_text(ui_Backlight_Time_Value);
    // atoi("off")会返回0, 这是可以利用的
    int backlightTimeLevel = backlight_time_second_to_level(atoi(second));

    if (backlightTimeLevel > 0) backlightTimeLevel--;

    set_backlight_time_to_label(ui_Backlight_Time_Value, backlightTimeLevel);
}
// 进入熄屏
static void offScreen_callback(void *pvParameter) {
    printf("Sleep\n");
    // 关闭背光
    set_backlight(0);
    // 在非music和music_play界面, 回到main
    if (lv_scr_act() != ui_Music_Play_Window && lv_scr_act() != ui_Music_Window) {
        lv_scr_load(ui_Main_Window);
    }
    // 启用"从熄屏中醒来"的可触摸区域
    lv_obj_clear_flag(current_screen_on_screen_range, LV_OBJ_FLAG_HIDDEN);
}
void offScreen(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call(offScreen_callback, NULL);
}
// 从熄屏中醒来
static void onScreen_callback(void *pvParameter) {
    printf("Wakeup\n");
    // 恢复背光
    set_backlight(backlight_level);
    lv_obj_add_flag(current_screen_on_screen_range, LV_OBJ_FLAG_HIDDEN);
}
void onScreen(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call(onScreen_callback, NULL);
}
// 从待机界面回到主界面
void idleBackToMainWindow(lv_event_t *e) {
    lv_scr_load(ui_Main_Window);
    reset_backlight_timer();
}

// ******************** 蓝牙相关 ********************

// 更改蓝牙设置
static void bluetooth_cfg_task(void *pvParameter) {
    char command[50];
    snprintf(command, sizeof(command), "AT+BE%s", bluetooth_ui_pass);
    bluetooth_send_at_command(command, CMD_BLUETOOTH_SET_PASSWORD);
    xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_SET_PASSWORD, pdTRUE, pdFALSE, 3000);

    snprintf(command, sizeof(command), "AT+BD%s", bluetooth_ui_name);
    bluetooth_send_at_command(command, CMD_BLUETOOTH_SET_NAME);
    // 等待模块重启
    xEventGroupWaitBits(bt_event_group, EVENT_STARTUP_SUCCESS, pdTRUE, pdFALSE, portMAX_DELAY);
    bluetooth_sync_cfg();
    vTaskDelete(NULL);
}
// 同步蓝牙界面与蓝牙的真实配置
static void bluetooth_sync_cfg(void) {
    bluetooth_send_at_command("AT+CM1", CMD_CHANGE_TO_BLUETOOTH);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_BLUETOOTH, pdTRUE, pdFALSE, portMAX_DELAY);
    work_mode = 1;
    bluetooth_send_at_command("AT+TD", CMD_BLUETOOTH_GET_NAME);
    xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_GET_NAME, pdTRUE, pdFALSE, portMAX_DELAY);
    bluetooth_send_at_command("AT+TE", CMD_BLUETOOTH_GET_PASSWORD);
    xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_GET_PASSWORD, pdTRUE, pdFALSE, portMAX_DELAY);
    bluetooth_send_at_command("AT+CM0", CMD_CHANGE_TO_IDLE);
    xEventGroupWaitBits(bt_event_group, EVENT_CHANGE_TO_IDLE, pdTRUE, pdFALSE, portMAX_DELAY);
    work_mode = 0;
    bluetooth_ui_name = bluetooth_name;
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    lv_label_set_text(ui_Bluetooth_Name_Value, bluetooth_ui_name);

    bluetooth_ui_pass = bluetooth_password;
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
    lv_label_set_text(ui_Bluetooth_Password_Value, bluetooth_ui_pass);
}

// 初始化蓝牙设置
void initBluetoothSettings(lv_event_t *e) {
    if (xSemaphoreTake(init_phase_semaphore, portMAX_DELAY) == pdTRUE) {
        bluetooth_sync_cfg();
        xSemaphoreGive(init_phase_semaphore);
    }
}
// 确认保存蓝牙设置
void saveBluetoothSetting(lv_event_t *e) {
    const char *name = lv_textarea_get_text(ui_Bluetooth_Name_Input2);
    bluetooth_ui_name = strdup(name);
    const char *password = lv_textarea_get_text(ui_Bluetooth_Password_Input2);
    bluetooth_ui_pass = strdup(password);
    xTaskCreate(bluetooth_cfg_task, "bluetooth_cfg_task", 4096, NULL, 5, NULL);
}
// 取消保存蓝牙设置
void cancelSaveBluetoothSetting(lv_event_t *e) {
    // 改完蓝牙设置后没点保存就退出界面, 就把原先的值设回来, 因为是textarea
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
}

// ******************** 时间相关 ********************

// 确认保存时间与日期
void saveTimeSetting(lv_event_t *e) {
    // 检查时间输入
    const char *hour_text = lv_textarea_get_text(ui_Time_Setting_Hour2);
    const char *min_text = lv_textarea_get_text(ui_Time_Setting_Min2);
    int hour = atoi(hour_text);
    int min = atoi(min_text);
    if (hour < 0 || hour > 23 || min < 0 || min > 59) {
        char hour_text[3];
        snprintf(hour_text, sizeof(hour_text), "%02ld", time_hour);
        lv_textarea_set_text(ui_Time_Setting_Hour2, hour_text);
        char min_text[3];
        snprintf(min_text, sizeof(min_text), "%02ld", time_min);
        lv_textarea_set_text(ui_Time_Setting_Min2, min_text);
        ESP_LOGE("saveTimeSetting", "Invalid input: hour=%s, minute=%s", hour_text, min_text);
        return;
    }
    time_hour = hour;
    time_min = min;
    // 检查日期输入
    const char *year_text = lv_textarea_get_text(ui_Date_Setting_Year2);
    const char *month_text = lv_textarea_get_text(ui_Date_Setting_Month2);
    const char *day_text = lv_textarea_get_text(ui_Date_Setting_Day2);
    uint32_t year = (uint32_t)atoi(year_text);
    uint32_t month = (uint32_t)atoi(month_text);
    uint32_t day = (uint32_t)atoi(day_text);
    if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        char year_text[5];
        snprintf(year_text, sizeof(year_text), "%ld", date_year);
        lv_textarea_set_text(ui_Date_Setting_Year2, year_text);
        char month_text[3];
        snprintf(month_text, sizeof(month_text), "%02ld", date_month);
        lv_textarea_set_text(ui_Date_Setting_Month2, month_text);
        char day_text[3];
        snprintf(day_text, sizeof(day_text), "%02ld", date_day);
        lv_textarea_set_text(ui_Date_Setting_Day2, day_text);
        ESP_LOGE("saveDateSetting", "Invalid input: year=%s, month=%s, day=%s", year_text, month_text, day_text);
        return;
    }
    date_year = year;
    date_month = month;
    date_day = day;
    global_time = convertToTimestamp(date_year, date_month, date_day, time_hour, time_min);
    if (update_time_task_handle == NULL) {
        xTaskCreate(update_time_task, "updateTimeTask", 2048, NULL, 5, &update_time_task_handle);
    }
}
// 取消保存时间设置
void cancelSaveTimeSettings(lv_event_t *e) {
    // 转换时间小时为字符串并设置文本区域
    char hour_str[3];  // 假设小时不会超过两位数
    snprintf(hour_str, sizeof(hour_str), "%02ld", time_hour);
    lv_textarea_set_text(ui_Time_Setting_Hour2, hour_str);

    // 转换时间分钟为字符串并设置文本区域
    char min_str[3];  // 假设分钟不会超过两位数
    snprintf(min_str, sizeof(min_str), "%02ld", time_min);
    lv_textarea_set_text(ui_Time_Setting_Min2, min_str);

    // 转换日期年份为字符串并设置文本区域
    char year_str[5];  // 假设年份最多四位数
    snprintf(year_str, sizeof(year_str), "%ld", date_year);
    lv_textarea_set_text(ui_Date_Setting_Year2, year_str);

    // 转换日期月份为字符串并设置文本区域
    char month_str[3];  // 假设月份不会超过两位数
    snprintf(month_str, sizeof(month_str), "%02ld", date_month);
    lv_textarea_set_text(ui_Date_Setting_Month2, month_str);

    // 转换日期天数为字符串并设置文本区域
    char day_str[3];  // 假设日期不会超过两位数
    snprintf(day_str, sizeof(day_str), "%02ld", date_day);
    lv_textarea_set_text(ui_Date_Setting_Day2, day_str);
}
// ******************** 声音相关 ********************

static void volume_timer_callback(TimerHandle_t xTimer);
// 初始化默认音量与最大音量与浴室播放通道
void initVolumeSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to open NVS");
        return;
    }
    // 读取 defaultVolume
    err = nvs_get_u32(nvs_handle, "defaultVolume", &defaultVolume);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'defaultVolume', 将写入默认值 %ld", defaultVolume);
        err = nvs_set_u32(nvs_handle, "defaultVolume", defaultVolume);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set defaultVolume in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get defaultVolume from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    current_volume = defaultVolume;

    volume_timer = xTimerCreate("VolumeTimer", pdMS_TO_TICKS(100), pdFALSE, NULL, volume_timer_callback);
    // 同步音量显示和实际
    if (xSemaphoreTake(init_phase_semaphore, portMAX_DELAY) == pdTRUE) {
        volume_timer_callback(NULL);
        xSemaphoreGive(init_phase_semaphore);
    }

    // 读取 maxVolume
    err = nvs_get_u32(nvs_handle, "maxVolume", &maxVolume);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'maxVolume', 将写入默认值 %ld", maxVolume);
        err = nvs_set_u32(nvs_handle, "maxVolume", maxVolume);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set maxVolume in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get maxVolume from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);

    // 读取 bathChannel
    err = nvs_get_u32(nvs_handle, "bathChannel", &bath_channel_bit);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'bathChannel', 将写入默认值 %ld", bath_channel_bit);
        err = nvs_set_u32(nvs_handle, "bathChannel", bath_channel_bit);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set bathChannel in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get bathChannel from NVS: %s", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
    switch (bath_channel_bit) {
        case 0:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 1:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 2:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 3:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
    }

    
}
// 增加默认音量
void addDefaultVolume(lv_event_t *e) {
    // 如果默认音量试图比最大音量高, 拒绝
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);

    if (tmp_default_volume >= tmp_max_volume) {
        return;
    }
    tmp_default_volume = (tmp_default_volume < 15) ? tmp_default_volume + 1 : 15;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
}
// 减少默认音量
void decDefaultVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);
    tmp_default_volume = (tmp_default_volume > 1) ? tmp_default_volume - 1 : 1;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
}
// 增加最大音量
void addMaxVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    tmp_max_volume = (tmp_max_volume < 15) ? tmp_max_volume + 1 : 15;
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%d", tmp_max_volume);
}
// 减少最大音量
void decMaxVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    tmp_max_volume = (tmp_max_volume > 1) ? tmp_max_volume - 1 : 1;
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%d", tmp_max_volume);

    // 如果最大音量比默认音量还低, 就顺便把默认音量也减少
    text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);
    if (tmp_default_volume > tmp_max_volume) {
        tmp_default_volume--;
        lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
    }
}
// 确认保存音量设置
void saveVolumeSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to open NVS");
        return;
    }
    // 默认音量
    const char *text = lv_label_get_text(ui_Default_Volume_Value);
    defaultVolume = atoi(text);
    err = nvs_set_u32(nvs_handle, "defaultVolume", defaultVolume);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to set defaultVolume in NVS");
        nvs_close(nvs_handle);
        return;
    }
    // 最大音量
    text = lv_label_get_text(ui_Max_Volume_Value);
    maxVolume = atoi(text);
    err = nvs_set_u32(nvs_handle, "maxVolume", maxVolume);
    if (err != ESP_OK) {
        ESP_LOGE("saveMaxVolume", "Failed to set maxVolume in NVS");
        nvs_close(nvs_handle);
        return;
    }
    if (current_volume > maxVolume) {
        current_volume = maxVolume;
    }
    update_header_volume();
    volume_timer_callback(NULL);
    // 浴室通道
    bool left_switch_checked = lv_obj_get_state(ui_Bath_Play_Left_Channel_Switch) & LV_STATE_CHECKED;
    bool right_switch_checked = lv_obj_get_state(ui_Bath_Play_Right_Channel_Switch) & LV_STATE_CHECKED;

    if (left_switch_checked && right_switch_checked) {
        bath_channel_bit = 3;
    } else if (left_switch_checked && !right_switch_checked) {
        bath_channel_bit = 2;
    } else if (!left_switch_checked && right_switch_checked) {
        bath_channel_bit = 1;
    } else {
        bath_channel_bit = 0;
    }
    err = nvs_set_u32(nvs_handle, "bathChannel", bath_channel_bit);
    if (err != ESP_OK) {
        ESP_LOGE("saveBathChannel", "Failed to set saveBathChannel in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
    // 如果在播放浴室音乐就即时更改通道, 音乐库和自然之音则不可能在播放时还能在设置界面
    if (bath_play_task_handle != NULL) {
        open_bath_channel();
    }
}
// 取消保存声音设置
void cancelSaveVolumeSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);
    switch (bath_channel_bit) {
        case 0:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 1:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 2:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 3:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
    }
}
// 打开音量调节块
void openVolumeAdjust(lv_event_t *e) {
    lv_obj_clear_flag(current_screen_volume_component, LV_OBJ_FLAG_HIDDEN);
}
// 关闭音量调节块
void closeVolumeAdjust(lv_event_t * e) {
    lv_obj_add_flag(current_screen_volume_component, LV_OBJ_FLAG_HIDDEN);
}
// 改变音量
static void volume_timer_callback(TimerHandle_t xTimer) {
    char command[20];
    snprintf(command, sizeof(command), "AT+CA%02d", current_volume * 2);
    bluetooth_send_at_command(command, CMD_SET_VOLUME);
    xEventGroupWaitBits(bt_event_group, EVENT_SET_VOLUME, pdTRUE, pdFALSE, portMAX_DELAY);
}
void changeVolume(lv_event_t * e) {
    lv_obj_t * slider = lv_event_get_target(e); // 获取触发事件的对象
    int value = lv_slider_get_value(slider); // 获取滑块的值
    printf("Slider value: %d\n", value);

    current_volume = (value * maxVolume) / MAX_VOLUME_LIMIT / 2;
    update_header_volume();
    xTimerReset(volume_timer, 0);
}


// ******************** 系统相关 ********************

// 初始化系统设置
void initSystemSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initSystemSettings", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    // 读取 ID
    err = nvs_get_u32(nvs_handle, "ID", &system_id);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        system_id = 1;
        ESP_LOGW("initSystemSettings", "NVS中未找到'ID', 将写入默认值 %ld", system_id);
        err = nvs_set_u32(nvs_handle, "ID", system_id);
        if (err != ESP_OK) {
            ESP_LOGE("initSystemSettings", "Failed to set default ID in NVS: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_commit(nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("initSystemSettings", "Failed to commit NVS changes: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initSystemSettings", "Failed to get ID from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);
    nvs_close(nvs_handle);
}
// 确认保存系统设置
void saveSystemSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to open NVS");
        return;
    }

    const char *text = lv_label_get_text(ui_System_ID_Value);
    system_id = atoi(text);

    err = nvs_set_u32(nvs_handle, "ID", system_id);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to set ID in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
}
// 取消保存系统设置
void cancelSaveSystemSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);
}
// 增加ID
void addID(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_System_ID_Value);
    int id = atoi(text);
    id = (id < 7) ? id + 1 : 7;
    lv_label_set_text_fmt(ui_System_ID_Value, "%d", id);
}
// 减少ID
void decID(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_System_ID_Value);
    int id = atoi(text);
    id = (id > 0) ? id - 1 : 0;
    lv_label_set_text_fmt(ui_System_ID_Value, "%d", id);
}
// 确认恢复出厂设置
void verifyResetFactory(lv_event_t *e)
{
    // 擦除 NVS
    esp_err_t err = nvs_flash_erase();
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "NVS擦除失败: %s", esp_err_to_name(err));
        return;
    } else {
        ESP_LOGI("verifyResetFactory", "NVS擦除成功");
    }
    // 初始化nvs
    err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    if (err == ESP_OK) {
        ESP_LOGI("verifyResetFactory", "NVS初始化成功");
    } else {
        ESP_LOGE("verifyResetFactory", "NVS初始化失败: %s", esp_err_to_name(err));
        return;
    }

    nvs_handle_t nvs_handle;

    // 重置所有nvs设置

    // 重置背光设置
    err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_bk_level = 3;
    uint32_t new_bk_time_level = 4;
    err = nvs_set_u32(nvs_handle, "level", new_bk_level);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'level': %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "time", new_bk_time_level);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'time': %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "背光设置重置为level: %ld, time: %ld", new_bk_level, new_bk_time_level);
    }
    nvs_close(nvs_handle);

    backlight_level = new_bk_level;
    backlight_time_level = new_bk_time_level;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);
    set_backlight(backlight_level);
    set_backlight_time_to_label(ui_Backlight_Time_Value, backlight_time_level);


    // 重置声音设置
    err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_default_volume = 8;
    uint32_t new_max_volume = 15;
    uint32_t new_bath_channel = 3; 
    err = nvs_set_u32(nvs_handle, "defaultVolume", new_default_volume);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set defaultVolume: %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "maxVolume", new_max_volume);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set maxVolume: %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "bathChannel", new_bath_channel);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set bathChannel: %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "声音设置重置为default: %ld, max: %ld, bathChannel: %ld", new_default_volume, new_max_volume, new_bath_channel);
    }
    nvs_close(nvs_handle);

    defaultVolume = new_default_volume;
    maxVolume = new_max_volume;
    bath_channel_bit = new_bath_channel;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);


    // 重置ID
    err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_id = 0;
    err = nvs_set_u32(nvs_handle, "ID", new_id);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default ID: %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "ID重置为 %ld", new_id);
    }
    nvs_close(nvs_handle);
    system_id = new_id;
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);


    // 重置WiFi设置
    err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint8_t new_enabled = 0;
    char new_wifi_ssid[] = "12345678";
    char new_wifi_password[] = "12345678";
    err = nvs_set_u8(nvs_handle, "enabled", new_enabled);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'enabled': %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_set_str(nvs_handle, "name", new_wifi_ssid);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set name in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_set_str(nvs_handle, "password", new_wifi_password);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set password in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes");
    } else {
        ESP_LOGI("verifyResetFactory", "WIFI设置重置为enabled: %d, ssid: %s, pass: %s", new_enabled, new_wifi_ssid, new_wifi_password);
    }
    nvs_close(nvs_handle);

    wifi_ssid = strdup(new_wifi_ssid);
    wifi_password = strdup(new_wifi_password);
    lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    if (new_enabled == 1) {
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        wifi_disconnect();
    }


    // 重置蓝牙配置(虽然这个不操作nvs)
    bluetooth_ui_name = "Hotel";
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    bluetooth_ui_pass = "0000";
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
    xTaskCreate(bluetooth_cfg_task, "bluetooth_cfg_task", 4096, NULL, 5, NULL);
    vTaskDelay(2000 / portTICK_PERIOD_MS);  // 等待蓝牙复位
    ESP_LOGI("verifyResetFactory", "蓝牙设置重置为name: %s, pass: %s", bluetooth_ui_name, bluetooth_ui_pass);


    // 重置时间设置(不操作nvs)
    lv_textarea_set_text(ui_Time_Setting_Hour2, "11");
    lv_textarea_set_text(ui_Time_Setting_Min2, "42");
    lv_textarea_set_text(ui_Date_Setting_Year2, "2022");
    lv_textarea_set_text(ui_Date_Setting_Month2, "04");
    lv_textarea_set_text(ui_Date_Setting_Day2, "13");
    ESP_LOGI("verifyResetFactory", "时间设置重置完成, 这个到底有什么用?");

    // 重置完也把音乐列表clear了, 要把状态和图标改掉
    create_music_item_complete = false;
    lv_obj_clear_flag(ui_tfcard_unavailable_the_X, LV_OBJ_FLAG_HIDDEN);

}
// 取消恢复出厂设置
void cancelResetFactory(lv_event_t *e)
{

}
// 曲目刷新
void track_refresh_task_callback(void *pvParameter) {
    lv_obj_add_flag(ui_TrackRefreshMsgPanel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(ui_PleaseRestartMsgPanel, LV_OBJ_FLAG_HIDDEN);
}
static void track_refresh_task(void *pvParameters) {
    // 获得文件名列表
    get_all_file_names();
    xEventGroupWaitBits(bt_event_group, EVENT_FILE_LIST_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);
    // 获得音乐库的歌的时长
    get_all_music_duration();
    xEventGroupWaitBits(bt_event_group, EVENT_ALL_DURATION_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);
    lv_async_call(track_refresh_task_callback, NULL);
    vTaskDelete(NULL);
}
void track_refresh(lv_event_t *e) {
    xTaskCreate(track_refresh_task, "track_refresh_task", 8192, NULL, 5, NULL);
}

// ******************** Wifi相关 ********************

// 初始化Wifi名称与密码
void initWifiSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    // 读取wifi开关状态
    err = nvs_get_u8(nvs_handle, "enabled", &wifi_enabled);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        wifi_enabled = 0;
        ESP_LOGW("initWifiSettings", "NVS中未找到'enabled', 将写入默认值 %d", wifi_enabled);
        err = nvs_set_u8(nvs_handle, "enabled", wifi_enabled);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set default value for 'enabled': %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_commit(nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to commit 'enabled' to NVS: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to get 'enabled' from NVS: %s", esp_err_to_name(err));
    }

    // 读取Wifi名称
    size_t required_size = 0;
    err = nvs_get_str(nvs_handle, "name", NULL, &required_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGE("initWifiSettings", "Failed to get size for name from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    if (required_size > 0) {
        char *tempWifiName = malloc(required_size);
        if (tempWifiName == NULL) {
            ESP_LOGE("initWifiSettings", "Failed to allocate memory for Wifi name");
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_get_str(nvs_handle, "name", tempWifiName, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to get name from NVS: %s", esp_err_to_name(err));
            free(tempWifiName);
            nvs_close(nvs_handle);
            return;
        }
        wifi_ssid = tempWifiName;
        lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    } else {
        ESP_LOGW("initWifiSettings", "NVS中未找到'name', 将写入默认值 12345678");
        err = nvs_set_str(nvs_handle, "name", "12345678");
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set name in NVS");
            nvs_close(nvs_handle);
            return;
        }
        wifi_ssid = "12345678";
        lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    }

    // 读取Wifi密码
    required_size = 0;
    err = nvs_get_str(nvs_handle, "password", NULL, &required_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGE("initWifiSettings", "Failed to get size for password from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    if (required_size > 0) {
        char *tempWifiPassword = malloc(required_size);
        if (tempWifiPassword == NULL) {
            ESP_LOGE("initWifiSettings", "Failed to allocate memory for Wifi password");
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_get_str(nvs_handle, "password", tempWifiPassword, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to get password from NVS: %s", esp_err_to_name(err));
            free(tempWifiPassword);
            nvs_close(nvs_handle);
            return;
        }
        wifi_password = tempWifiPassword;
        lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    } else {
        ESP_LOGW("initWifiSettings", "NVS中未找到'password', 将写入默认值 12345678");
        err = nvs_set_str(nvs_handle, "password", "12345678");
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set password in NVS");
            nvs_close(nvs_handle);
            return;
        }
        wifi_password = "12345678";
        lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);

    if (wifi_enabled == 0) {
        // 如果禁用wifi, 把相关UI禁用后返回
        lv_obj_clear_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);

        // 连接WiFi并获得时间
        start_wifi_connect_task(wifi_ssid, wifi_password);
    }
}
// 确认保存Wifi名称与密码
void saveWifiSetting(lv_event_t *e) {
    const char *name = lv_textarea_get_text(ui_Wifi_SSID_Input);
    if (name != NULL) {
        if (wifi_ssid != NULL)
            free(wifi_ssid);
        wifi_ssid = strdup(name);
    }
    const char *password = lv_textarea_get_text(ui_Wifi_Password_Input);
    if (password != NULL) {
        if (wifi_password != NULL) free(wifi_password);
        wifi_password = strdup(password);
    }

    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to open NVS");
        return;
    }

    wifi_enabled = lv_obj_has_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
    err = nvs_set_u8(nvs_handle, "enabled", wifi_enabled ? 1 : 0);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set enabled in NVS: %s", esp_err_to_name(err));
    }

    err = nvs_set_str(nvs_handle, "name", name);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set name in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_set_str(nvs_handle, "password", password);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set password in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to commit NVS changes");
    }

    nvs_close(nvs_handle);

    if (wifi_enabled == 1) {
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        lv_img_set_src(ui_Wifi_States_Icon, &ui_img_236134236);

        start_wifi_connect_task(name, password);
        if (wait_wifi_connect_task_handle != NULL) {
            vTaskDelete(wait_wifi_connect_task_handle);
            wait_wifi_connect_task_handle = NULL;
        }
    } else {
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        if (wait_wifi_connect_task_handle != NULL) {
            vTaskDelete(wait_wifi_connect_task_handle);
            wait_wifi_connect_task_handle = NULL;
        }
        wifi_disconnect();
    }
}

// ******************** 音乐相关 ********************

// 点击主界面的音乐库按钮时的回调
void attempt_enter_music_window(lv_event_t *e) {
    if (device_state != 2) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "TF卡未插入");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
    } else if (create_music_item_complete != true) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "未刷新曲目");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
    } else {
        lv_scr_load(ui_Music_Window);
    }
}
// 更新进度条与时间标签的回调函数
static void update_progress_callback(void *pvParameter) {
    if (currentPlayTime < current_music_duration) {
        currentPlayTime++;
        // 更新当前时间标签
        char time_str[9];  // hh:mm:ss
        format_time(currentPlayTime, time_str, sizeof(time_str));
        lv_label_set_text(ui_Current_Time, time_str);

        int progressValue = (currentPlayTime * 100) / (current_music_duration);
        lv_slider_set_value(ui_Progress_Slider, progressValue, LV_ANIM_OFF);
    } else {
        if (progressTimer != NULL) {
            lv_img_set_src(ui_Play_Pause_Icon, &ui_img_2101671624);
            lv_timer_pause(progressTimer);  // 停止定时器
        }
    }
}
static void update_progress(lv_timer_t *timer) {
    lv_async_call(update_progress_callback, NULL);
}
// 初始化音频进度条定时器
static void initProgressBar(void) {
    // 创建定时器，每秒更新一次
    progressTimer = lv_timer_create(update_progress, 1000, NULL);
    lv_timer_pause(progressTimer);  // 初始化时暂停定时器
}
// 设置新的进度条
static void create_protgress_bar(void) {
    current_music_duration = music_durations[current_playing_index] - 1;    // 将总时长减1秒以更好地...做许多事
    char time_str[12];
    format_time(current_music_duration, time_str, sizeof(time_str));
    ESP_LOGI("create_protgress_bar", "Total time: %s", time_str);
    lv_label_set_text(ui_Total_Time, time_str);

    currentPlayTime = 0;

    lv_timer_reset(progressTimer);  // 重置进度条
    lv_timer_resume(progressTimer); // 然后启动
}
// 关闭EVENT_PLAY_MUSIC_WITH_ID位的任务, AT响应实际上非常快, 但还是会阻塞界面, 不知道有没有必要这么做, 也许就不管它而在退出音乐库时clear得了
static void clear_play_event_bit_task(void *pvParameter) {
    xEventGroupClearBits(music_event_group, EVENT_PLAY_MUSIC_WITH_ID);
    vTaskDelete(NULL);
}
// 播放指定index的音乐(file_names里的index)
static void playMusicWithCurrentIndex(void) {
    // 如果浴室在播放, 关掉它
    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
        ESP_LOGI("close bath play", "已关闭浴室音乐");
    }

    char command[50];
    int id;
    sscanf(file_names[current_playing_index], "%2d", &id);
    // index从0开始, 文件id从01开始
    snprintf(command, sizeof(command), "AT+AF%02d", id);
    bluetooth_send_at_command(command, CMD_PLAY_MUSIC_WITH_ID);
    xTaskCreate(clear_play_event_bit_task, "clear_play_event_bit_task", 1024, NULL, 2, NULL);

    create_protgress_bar();

    // 在列表中高亮指定的音乐名字
    if (current_playing_music_obj != NULL) {
        lv_obj_clear_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
    }
    current_playing_music_obj = music_obj_list[current_playing_index];
    lv_obj_add_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
    // 保证在列表中, 总是显示当前音乐所在的musicList页
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
    currentListIndex = current_playing_index / MAX_ITEMS_PER_LIST;
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 上一页音乐列表
void prevMusicList(lv_event_t *e) {
    if (numMusicLists == 0) return;
    // 隐藏当前列表
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);

    // 切换到上一个列表
    currentListIndex--;
    if (currentListIndex < 0) {
        currentListIndex = numMusicLists - 1;  // 循环到最后一个列表
    }

    // 显示这个列表
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 下一页音乐列表
void nextMusicList(lv_event_t *e) {
    if (numMusicLists == 0) return;
    // 隐藏当前列表
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);

    // 切换到下一个列表
    currentListIndex++;
    if (currentListIndex >= numMusicLists) {
        currentListIndex = 0;  // 循环到第一个列表
    }

    // 显示这个列表
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 播放Music List中被点击的音乐
void playSelectedMusic(lv_event_t *e) {
    // 在这一步才打开客厅通道
    open_living_room_channel();

    // 更新UI
    changeMusicUpdateUI();
    lv_obj_t *obj = lv_event_get_target(e);
    lv_obj_t *label = lv_obj_get_child(obj, 0);

    char *track_title = lv_label_get_text(label);
    lv_label_set_text(ui_Track_Title, track_title);
    lv_label_set_text(ui_Track_Artist, "null");

    lv_scr_load(ui_Music_Play_Window);

    // 获得当前试图播放的音乐在数组里的索引
    for (int i = 0; i < music_files_count; i++) {
        if (strcmp(track_title, file_names[i] + 2) == 0) {
            current_playing_index = i;
            break;
        }
    }
    printf("INDEX: %d\n", current_playing_index);

    if (play_mode == PLAY_MODE_SHUFFLE) {
        // 重置随机播放的索引
        shufflePlaylist();
        shuffle_list_index = -1;
        for (int i = 0; i < music_files_count; i++) {
            if (shuffle_order[i] == current_playing_index) {
                shuffle_list_index = i;
                break;
            }
        }
        if (shuffle_list_index == -1) {
            ESP_LOGE("shuffle", "错误索引");
        }
    }
    playMusicWithCurrentIndex();
}
// 下一首音乐
static void nextTrack_callback(void *pvParameter) {
    changeMusicUpdateUI();

    switch (play_mode) {
        case PLAY_MODE_LOOP:
            if (current_playing_index < music_files_count - 1) {
                current_playing_index++;
            } else {
                current_playing_index = 0;
            }
            break;
        case PLAY_MODE_SINGLE:
            // 不增加current_playing_index就行了
            break;
        case PLAY_MODE_SHUFFLE:
            if (shuffle_list_index < music_files_count - 1) {
                shuffle_list_index++;
            } else {
                shuffle_list_index = 0;
            }
            current_playing_index = shuffle_order[shuffle_list_index];
            break;
    }
    char *track_title;
    track_title = file_names[current_playing_index];
    lv_label_set_text(ui_Track_Title, track_title + 2);
    lv_label_set_text(ui_Track_Artist, "null");
    playMusicWithCurrentIndex();
}
void nextTrack(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新, 因为485指令也会调用这几个函数
    lv_async_call(nextTrack_callback, NULL);
}
// 上一首音乐
static void prevTrack_callback(void *pvParameter) {
    changeMusicUpdateUI();
    char *track_title;

    switch (play_mode) {
        case PLAY_MODE_LOOP:
            if (current_playing_index > 0) {
                current_playing_index--;
            } else {
                current_playing_index = music_files_count - 1;
            }
            break;
        case PLAY_MODE_SINGLE:
            // 不增加current_playing_index
            break;
        case PLAY_MODE_SHUFFLE:
            if (shuffle_list_index > 0) {
                shuffle_list_index--;
            } else {
                shuffle_list_index = music_files_count - 1;
            }
            current_playing_index = shuffle_order[shuffle_list_index];
            break;
    }
    track_title = file_names[current_playing_index];
    lv_label_set_text(ui_Track_Title, track_title + 2);
    lv_label_set_text(ui_Track_Artist, "null");
    playMusicWithCurrentIndex();
}
void prevTrack(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call(prevTrack_callback, NULL);
}
// 播放/暂停
static void playPause_callback(void *pvParameter) {
    bluetooth_send_at_command("AT+CB", CMD_PLAY_PAUSE_TOGGLE);
    xEventGroupWaitBits(music_event_group, EVENT_PLAY_PAUSE_TOGGLE, pdTRUE, pdFALSE, portMAX_DELAY);
    // 如果是在播放音乐库音乐就修改UI
    if (music_play_task_handle != NULL) {
        if (playing) {
            // 暂停
            lv_timer_pause(progressTimer);
            lv_img_set_src(ui_Play_Pause_Icon, &ui_img_2101671624);
            printf("暂停\n");
            playing = false;
        } else {
            // 播放
            lv_timer_resume(progressTimer);
            lv_img_set_src(ui_Play_Pause_Icon, &ui_img_899744137);
            printf("播放\n");
            playing = true;
        }
    }
}
void playPause(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call(playPause_callback, NULL);
}
// 切换播放模式
void changePlayMode(lv_event_t *e) {
    switch (play_mode) {
        case PLAY_MODE_LOOP:
            play_mode = PLAY_MODE_SINGLE;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_1071321554);
            break;
        case PLAY_MODE_SINGLE:
            play_mode = PLAY_MODE_SHUFFLE;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_1311962515);
            // 洗完牌后设置很难描述的索引
            shufflePlaylist();
            shuffle_list_index = -1;
            for (int i = 0; i < music_files_count; i++) {
                if (shuffle_order[i] == current_playing_index) {
                    shuffle_list_index = i;
                    break;
                }
            }
            if (shuffle_list_index == -1) {
                ESP_LOGE("shuffle", "错误索引");
            }
            break;
        case PLAY_MODE_SHUFFLE:
            play_mode = PLAY_MODE_LOOP;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_260357382);
            break;
        default:
            play_mode = PLAY_MODE_LOOP;
            ESP_LOGE("changePlayMode", "我为什么又要写这种东西");
            break;
    }
}

// ******************** 均衡器相关 ********************

void select_eq_nature(lv_event_t *e) {
    lv_obj_add_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x228B22), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    
    equalizer_mode = EQ_MODE_NATURE;
    lv_label_set_text(ui_Play_Style_Text, "自然");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ5", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);
}
void select_eq_jazz(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x6A5ACD), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_JAZZ;
    lv_label_set_text(ui_Play_Style_Text, "爵士");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ4", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);

}
void select_eq_rock(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0xDC143C), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_ROCK;
    lv_label_set_text(ui_Play_Style_Text, "摇滚");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ1", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);

}
void select_eq_pop(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0xFF1493), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_POP;
    lv_label_set_text(ui_Play_Style_Text, "流行");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ2", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);

}
void select_eq_classical(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0xFFD700), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_CLASSICAL;
    lv_label_set_text(ui_Play_Style_Text, "古典");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ3", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);

}
void select_eq_opera(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x8B0000), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_OPERA;
    lv_label_set_text(ui_Play_Style_Text, "歌剧");
    close_music_EQ_Panel(NULL);
    bluetooth_send_at_command("AT+CQ0", CMD_EQUALIZER_SET);
    xEventGroupWaitBits(music_event_group, EVENT_EQUALIZER_SET, pdTRUE, pdFALSE, portMAX_DELAY);
}
// 打开切换均衡器的窗口
void changePlayStyle(lv_event_t * e)
{
    lv_obj_clear_flag(ui_Music_Window_EQ_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(ui_CloseMusicEQPanelRange, LV_OBJ_FLAG_HIDDEN);
}
// 关闭切换均衡器的窗口
void close_music_EQ_Panel(lv_event_t * e) {
    lv_obj_add_flag(ui_Music_Window_EQ_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_CloseMusicEQPanelRange, LV_OBJ_FLAG_HIDDEN);
}
// ******************** 自然之音相关 ********************

// 点击主界面的自然之音按钮时的回调
void attempt_enter_nature_window(lv_event_t *e) {
    if (device_state != 2) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "TF卡未插入");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
    } else if (create_music_item_complete != true) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "未刷新曲目");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
    } else {
        lv_scr_load(ui_Nature_Sound_Window);
    }
}
// 重复播放指定自然之音的任务
static void selectNatureSoundTask(void *pvParameter) {
    // 只要开始播放任意一个自然之音, 就删除不活动定时器, 无论如何都不自动返回主界面, 仅能手动返回
    del_inactive_timer();

    char *sound_name = (char *)pvParameter;

    int id = -1;
    for (int i = 0; i < 4; i++) {
        if(strncmp(file_names[music_files_count + bath_files_count + i] + 2, sound_name, 3) == 0) {
            sscanf(file_names[music_files_count + bath_files_count + i], "%2d", &id);
            break;
        }
    }
    if (id == -1) {
        ESP_LOGE("selectNatureSoundTask", "未找到自然之音, name: %s", sound_name);
    }
    open_living_room_channel();

    char command[32];
    snprintf(command, sizeof(command), "AT+AF%02d", id);

    while (1) {
        // 如果浴室在播放, 关掉它
        if (bath_play_task_handle != NULL) {
            vTaskDelete(bath_play_task_handle);
            bath_play_task_handle = NULL;
            ESP_LOGI("selectNatureSoundTask", "已关闭浴室音乐");
        }
        bluetooth_send_at_command(command, CMD_PLAY_MUSIC_WITH_ID);
        xEventGroupWaitBits(music_event_group, EVENT_PLAY_MUSIC_WITH_ID, pdTRUE, pdFALSE, portMAX_DELAY);
        xEventGroupWaitBits(bt_event_group, EVENT_END_PLAY, pdTRUE, pdFALSE, portMAX_DELAY);
    }
}

void selectBirdSound(lv_event_t *e) {
    lv_obj_add_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    char sound_name[] = "Bird";
    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }
    xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, (void *)&sound_name, 5, &nature_play_task_handle);
}
void selectBugSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    char sound_name[] = "Bug";
    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }
    xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, (void *)&sound_name, 5, &nature_play_task_handle);
}
void selectForestSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    char sound_name[] = "Forest";
    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }
    xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, (void *)&sound_name, 5, &nature_play_task_handle);
}
void selectSeaSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    char sound_name[] = "Sea";
    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }
    xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, (void *)&sound_name, 5, &nature_play_task_handle);
}

// ******************** 真的找不到分类 ********************

// 试图进入设置界面
void attempt_enter_settings_window(void) {
    static uint8_t click_count = 0;
    static uint32_t last_click_time = 0;

    uint32_t current_time = lv_tick_get();

    if (current_time - last_click_time > ENTER_SETTINGS_WINDOW_CLICK_RESET_TIME) {
        click_count = 0; // 如果时间间隔超出设定的时间，重置点击计数
    }

    last_click_time = current_time;
    click_count++;

    if (click_count >= ENTER_SETTINGS_WINDOW_CLICK_COUNT) {
        click_count = 0; // 达到点击次数后重置计数
        lv_scr_load(ui_Settings_Window);
    }
}