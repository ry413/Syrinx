// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.0
// LVGL version: 8.3.6
// Project name: SquareLine_Project

// 很明显, 有许多鬼命名, 多亏了squareline导出的代码的格式与我代码风格的冲突

#include <esp_log.h>
#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
#include <freertos/task.h>
#include <locale.h>
#include <nvs.h>
#include "nvs_flash.h"
#include <stdio.h>
#include <sys/time.h>

#include "backlight.h"
#include "bluetooth.h"
#include "driver/uart.h"

#include "ui.h"
#include "ui_comp_music_item.h"
#include "wifi.h"
#include "rs485.h"

#include "esp_http_client.h"
#include "esp_mac.h"
#include "esp_heap_trace.h"

//////////////////// DEFINITIONS ////////////////////
#define MAX_ITEMS_PER_LIST 5                        // 每个MusicList里有几首歌
#define MAX_LISTS 10                                // 假设最多有 10 个 MusicList
#define INACTIVE_TIME 1 * 60 * 1000                 // 无操作几分钟就返回主界面的几
#define MAX_VOLUME_LIMIT 30                         // 真实的音量上限
#define ENTER_SETTINGS_WINDOW_CLICK_COUNT 5         // 进入设置界面需要点击的次数
#define ENTER_SETTINGS_WINDOW_CLICK_RESET_TIME 500  // 进入设置界面点击的间隔, 每两次点击间隔不能超过500ms
#define RESTART_ESP32_CLICK_RESET_TIME 500          // 试图复位esp32的点击间隔, 每两次点击间隔不能超过500ms

//////////////////// GLOBAL VARIABLES 乱爆了 ////////////////////

static lv_obj_t *musicLists[MAX_LISTS]; // 存储 MusicList 的指针数组
static int currentListIndex = 0;        // 当前 MusicList 的索引
static int numMusicLists = 0;           // MusicList 的总数

static bool playing = false;            // 播放状态
static lv_timer_t *progressTimer = NULL;// 音频进度条定时器
static int currentPlayTime = 0;         // 音频进度条的当前值

static lv_obj_t **music_obj_list = NULL;    // 储存所有歌的MusicItem对象, 用于实现当前播放高亮
static lv_obj_t *current_playing_music_obj; // 当前歌的MusicItem对象, 同样用于实现当前播放高亮

static lv_timer_t *inactive_timer;       // 不活动就返回主界面, 的定时器
static lv_timer_t *close_tf_card_notfound_msg_timer;    // 用来关闭"tf卡不存在"弹窗的定时器
static lv_timer_t *close_volume_adjust_timer;       // 自动关闭音量调节块的定时器


// ******************** 闹钟 ********************

// 被选中的铃声, 在ringtone_file_ids中的索引
static int selected_ringtone_index = 0;

// 延时更新闹钟时间, 为了更好看
static lv_timer_t *delay_update_alarm_clock_timer;

// 闹钟选择时间时, 被选中的时间
uint16_t alarm_clock_selected_hour;
uint16_t alarm_clock_selected_min;

// 如果保存了闹钟, 真正用的时间
uint16_t alarm_clock_hour;
uint16_t alarm_clock_min;
bool alarm_clock_enabled = true;

// 真正的闹钟timer
static TimerHandle_t alarm_clock_itself_timer = NULL;

// 闹钟是否准备响了, 用于几个特殊界面
static bool alarm_clock_ready_shouting = false;

// 闹钟响后, 循环播放闹铃的任务
TaskHandle_t alarm_clock_cycle_shout_task_handle = NULL;

// ******************** 闹钟 ********************

// ******************** 设置界面UI ********************

// 蓝牙名称与密码
char bluetooth_ui_name[13];
char bluetooth_ui_pass[5];

// 当前音量
int current_volume;
// 默认音量与最大音量
uint32_t defaultVolume = 8;
uint32_t maxVolume = 15;

// ID
uint32_t system_id = 0;

// ******************** 设置界面UI ********************


// 调节音量时的防抖定时器
static TimerHandle_t volume_timer = NULL;


// 当前页面的音量显示和音量调节块的指针, 写得好恶心.
// 还有从熄屏中醒来的点击范围
lv_obj_t * current_screen_header_volume = NULL;
lv_obj_t * current_screen_volume_adjust = NULL;
lv_obj_t * current_screen_on_screen_range = NULL;

// ******************** 播放模式 ********************

// 播放模式部分
int shuffle_list_index = 0;  // 当前播放的歌曲的index, 在洗牌数组里的索引
typedef enum {
    PLAY_MODE_LOOP,
    PLAY_MODE_SINGLE,
    PLAY_MODE_SHUFFLE,
} play_mode_t;

play_mode_t play_mode = PLAY_MODE_LOOP;  // 默认循环播放模式
int *shuffle_order;                      // 用于随机播放模式的洗牌数组

// ******************** 播放模式 ********************

// ******************** 均衡器 ********************
typedef enum {
    EQ_MODE_NATURE,     // 自然
    EQ_MODE_JAZZ,       // 爵士
    EQ_MODE_ROCK,       // 摇滚
    EQ_MODE_POP,        // 流行
    EQ_MODE_CLASSICAL,  // 古典
    EQ_MODE_OPERA       // 歌剧
} equalizer_t;

equalizer_t equalizer_mode = EQ_MODE_POP;

// ******************** 均衡器 ********************


// TaskHandle_t music_play_mode_task_handle = NULL;     // 这两个放在rs485.h声明了, 好惨
// TaskHandle_t nature_play_task_handle = NULL;
static TaskHandle_t bluetooth_monitor_state_task_handle = NULL;
static TaskHandle_t wait_wifi_connect_task_handle = NULL;

static char **file_names = NULL;
static uint32_t *music_durations = NULL;

// 开机初始化阶段会有某些地方争着发AT指令, 所以用个信号量
SemaphoreHandle_t init_phase_semaphore = NULL;

static bool create_music_item_complete = false;     // 如果已插入卡, 但是没有刷新音乐列表就进音乐库什么的会出事

// ******************** 屎山 ********************
static int current_nature_id;


//////////////////// STATIC FUNCTION DECLARATIONS ////////////////////
// 真有必要写这些吗

static void format_time(int seconds, char *buffer, size_t buffer_size);
static void update_progress(lv_timer_t *timer);
static void initProgressBar(void);
static void bluetooth_cfg_task(void *pvParameter);
static time_t convertToTimestamp(uint32_t year, uint32_t month, uint32_t day, uint32_t hour, uint32_t min);
static void inactive_callback(lv_timer_t *timer);
static void bluetooth_monitor_state_task(void *pvParameter);
static void changeMusicUpdateUI(void);
static void update_header_volume(void);
static void shufflePlaylist(void);
static void music_play_mode_task(void *pvParameter);
static void bluetooth_cfg_task(void *pvParameter);
static void bluetooth_sync_cfg(void);
static void selectNatureSoundTask(void *pvParameter);
static void close_tf_card_notfound_msg_timer_callback(lv_timer_t *timer);
static void delay_update_alarm_clock_time_callback(lv_timer_t *timer);
//////////////////// 不给lvgl事件直接调用的静态函数 ////////////////////

// 创建Music List及item
static void create_music_item(void) {
    // 从nvs中读取所有音乐文件名储存于file_names
    nvs_handle_t nvs_handle;
    esp_err_t err;

    err = nvs_open("filenames", NVS_READONLY, &nvs_handle);
    // 如果没有找到就自动刷新
    if (err != ESP_OK) {
        ESP_LOGE("create_music_item", "NVS中未找到filenames命名空间, 需要刷新");
        xEventGroupClearBits(bt_event_group, EVENT_REFRESH_COMPLETE);
        track_refresh(NULL);
        xEventGroupWaitBits(bt_event_group, EVENT_REFRESH_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);
        create_music_item();
        return;
    }

    // 读取字符串数量
    err = nvs_get_u32(nvs_handle, "music_count", &music_files_count);
    if (err != ESP_OK) {
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_get_u32(nvs_handle, "bath_count", &bath_files_count);
    if (err != ESP_OK) {
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_get_u32(nvs_handle, "ringtone_count", &ringtone_files_count);
    if (err != ESP_OK) {
        nvs_close(nvs_handle);
        return;
    }

    // 读取字符串们
    file_names = (char **)malloc((music_files_count + bath_files_count + ringtone_files_count + NATURE_SOUND_COUNT) * sizeof(char *));
    if (file_names == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory for file_names");
        nvs_close(nvs_handle);
        return;
    }
    for (int i = 0; i < music_files_count + bath_files_count + ringtone_files_count + NATURE_SOUND_COUNT; i++) {
        char key[16];
        snprintf(key, sizeof(key), "file_%u", (unsigned int)i);

        // 获取字符串长度
        size_t required_size;
        err = nvs_get_str(nvs_handle, key, NULL, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("create_music_item", "Failed to nvs_get_str required_size: [%d]", i);
            for (size_t j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }
        
        file_names[i] = (char *)malloc(required_size);
        if (file_names[i] == NULL) {
            ESP_LOGE("create_music_item", "Failed to allocate memory for file_names[%d]", i);
            for (int j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }

        err = nvs_get_str(nvs_handle, key, file_names[i], &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("create_music_item", "Failed to nvs_get_str: [%d]", i);
            for (size_t j = 0; j < i; j++) {
                free(file_names[j]);
            }
            free(file_names);
            nvs_close(nvs_handle);
            return;
        }
    }
    nvs_close(nvs_handle);

    // 以上只是从nvs中读文件名, 以下才是创建音乐item, 或许应该拆成两个函数

    music_obj_list = (lv_obj_t **)malloc(music_files_count * sizeof(lv_obj_t *));
    if (music_obj_list == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory for music_obj_list");
        return;
    }

    // 生成音乐库的音乐item
    musicLists[currentListIndex] = ui_Music_List_create(ui_Music_List_Container);
    numMusicLists++;
    int items_added = 0;
    for (int i = 0; i < music_files_count; i++) {
        // 如果当前列表的 Music_item 数量达到最大值，切换到下一个列表
        if (items_added >= MAX_ITEMS_PER_LIST) {
            currentListIndex++;
            if (currentListIndex >= MAX_LISTS) {
                ESP_LOGE("create_music_item_task", "Exceeded maximum number of lists");
                break;
            }
            // 创建新的 MusicList
            musicLists[currentListIndex] = ui_Music_List_create(ui_Music_List_Container);
            numMusicLists++;
            lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
            items_added = 0;  // 重置计数器
        }
        // 创建musicItem
        lv_obj_t *obj = ui_Music_Item_create(musicLists[currentListIndex]);

        // lv_obj_t *icon = lv_obj_get_child(obj, 2);
        // lv_img_set_src(icon, &ui_img_35201459);

        lv_obj_t *name_label = lv_obj_get_child(obj, 0);
        lv_label_set_text(name_label, file_names[i] + 2);

        music_obj_list[i] = obj;

        items_added++;
    }
    // 将当前显示的设置为第一个列表
    currentListIndex = 0;

    // 初始化闹铃选择界面的音乐item
    for (int i = 0; i < ringtone_files_count; i++) {
        // 闹铃应该不会怎么变, 所以当作只有4个吧
        lv_obj_t *obj = ui_Music_Item_create(ui_Ringtone_List);
        lv_obj_t *icon = lv_obj_get_child(obj, 2);
        lv_img_set_src(icon, &ui_img_tick_png);
        if (i != 0) {
            lv_obj_add_flag(icon, LV_OBJ_FLAG_HIDDEN);  // 默认选中第一个铃声, 所以这里不隐藏它的✅
        }

        lv_obj_t *name_label = lv_obj_get_child(obj, 0);
        lv_label_set_text_fmt(name_label, "铃声%d", i + 1);
    }
    
    // 顺便初始化一下进度条
    initProgressBar();

    // 显示正常的tf卡图标(把X隐藏掉)
    lv_obj_add_flag(ui_tfcard_unavailable_the_X, LV_OBJ_FLAG_HIDDEN);


    // 收集bath里的歌的id
    bath_file_ids = (int *)malloc(bath_files_count * sizeof(int));
    if (bath_file_ids == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory bath");
        return;
    }
    for (int i = 0; i < bath_files_count; i++) {
        // 提取id
        char id_str[3] = { file_names[music_files_count + i][0], file_names[music_files_count + i][1], '\0' };
        bath_file_ids[i] = atoi(id_str);
    }


    // 收集ringtone的id
    ringtone_file_ids = (int *)malloc(ringtone_files_count * sizeof(int));
    if (ringtone_file_ids == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory ringtone");
        return;
    }
    for (int i = 0; i < ringtone_files_count; i++) {
        // 提取id
        char id_str[3] = { file_names[music_files_count + bath_files_count + i][0], file_names[music_files_count + bath_files_count + i][1], '\0' };
        ringtone_file_ids[i] = atoi(id_str);
    }


    // 搜集nature_sound的id
    nature_file_ids = (int *)malloc(4 * sizeof(int));
    if (nature_file_ids == NULL) {
        ESP_LOGE("create_music_item", "Failed to allocate memory nature");
        return;
    }
    for (int i = 0; i < 4; i++) {
        // 提取id
        char id_str[3] = { file_names[music_files_count + bath_files_count + ringtone_files_count + i][0], file_names[music_files_count + bath_files_count + ringtone_files_count + i][1], '\0' };
        nature_file_ids[i] = atoi(id_str);
    }


    create_music_item_complete = true;
}
static void init_durations_for_nvs(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err;

    err = nvs_open("music_durations", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("init_durations_for_nvs", "NVS中未找到music_durations命名空间, 需要刷新");
        return;
    }

    // 读取duration们
    music_durations = (uint32_t *)malloc(music_files_count * sizeof(uint32_t));
    if (music_durations == NULL) {
        ESP_LOGE("init_durations_for_nvs", "Failed to allocate memory for music_durations");
        nvs_close(nvs_handle);
        return;
    }
    for (int i = 0; i < music_files_count; i++) {
        char key[16];
        snprintf(key, sizeof(key), "file_%u", (unsigned int)i);

        err = nvs_get_u32(nvs_handle, key, &music_durations[i]);
        if (err != ESP_OK) {
            ESP_LOGE("init_durations_for_nvs", "Failed to music_duration: [%d]", i);
            free(music_durations);
            nvs_close(nvs_handle);
            return;
        }
    }
    nvs_close(nvs_handle);
}
// 将秒转为hh:mm:ss
static void format_time(int seconds, char *buffer, size_t buffer_size) {
    int hours = seconds / 3600;
    int minutes = (seconds % 3600) / 60;
    int sec = seconds % 60;
    int ret = snprintf(buffer, buffer_size, "%02d:%02d:%02d", hours, minutes, sec);

    // 检查 snprintf 是否成功
    if (ret < 0 || ret >= buffer_size) {
        // 错误处理：确保缓冲区以 null 结尾
        if (buffer_size > 0) {
            buffer[0] = '\0';
        }
        fprintf(stderr, "Error formatting time string\n");
    }
}

// 时间转为时间戳
static time_t convertToTimestamp(uint32_t year, uint32_t month, uint32_t day, uint32_t hour, uint32_t min) {
    struct tm timeinfo;

    // 初始化 struct tm 结构
    timeinfo.tm_year = year - 1900;  // tm_year 从 1900 年开始计算
    timeinfo.tm_mon = month - 1;     // tm_mon 是从 0 到 11，所以减 1
    timeinfo.tm_mday = day;
    timeinfo.tm_hour = hour;  // 8小时时区
    timeinfo.tm_min = min;
    timeinfo.tm_sec = 0;
    timeinfo.tm_isdst = -1;  // 自动判断是否是夏令时

    // 将 struct tm 结构转换为时间戳
    time_t timestamp = mktime(&timeinfo);

    // 返回时间戳
    return timestamp;
}
// 不活动定时器的回调, 在非main界面无操作一定时间后, 从xx界面回到main界面
static void inactive_callback(lv_timer_t *timer) {
    // 记录当前screen
    // lv_obj_t *prevScreen = lv_scr_act();
    // 关闭当前页的音量调节块
    closeVolumeAdjust(NULL);
    lv_scr_load(ui_Main_Window);

    // del_inactive_timer();  不在这写这个, 而是放在mainScrLoaded, 因为主动返回主界面也要停止这个timer
}
// 创建不活动定时器
void create_inactive_timer(void) {
    if (inactive_timer == NULL) {
        inactive_timer = lv_timer_create(inactive_callback, INACTIVE_TIME, NULL);
    }
}
// 删除不活动定时器
void del_inactive_timer(void) {
    if (inactive_timer != NULL) {
        lv_timer_del(inactive_timer);
        inactive_timer = NULL;
    }
}
// 重置不活动定时器
void reset_inactive_timer(void) {
    if (inactive_timer != NULL) {
        lv_timer_reset(inactive_timer);
    }
}
// 感觉很危险的极性状态机
static void bluetooth_monitor_state_task(void *pvParameter) {
    while (1) {
        if (bluetooth_state == 2) {
            printf("蓝牙已连接\n");
            del_inactive_timer();
            // 等待断开事件
            xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_DISCONNECTED, pdTRUE, pdFALSE, portMAX_DELAY);
        } else if (bluetooth_state == 1) {
            printf("等待连接中\n");
            create_inactive_timer();
            // 等待连接事件
            xEventGroupWaitBits(bt_event_group, EVENT_BLUETOOTH_CONNECTED, pdTRUE, pdFALSE, portMAX_DELAY);
        }
    }
}
// 更新当前界面的音量显示
static void update_header_volume(void) {
    lv_label_set_text_fmt(lv_obj_get_child(current_screen_header_volume, 1), "%d", current_volume);
    lv_slider_set_value(lv_obj_get_child(current_screen_volume_adjust, 0), current_volume * 2 * MAX_VOLUME_LIMIT / maxVolume, LV_ANIM_OFF);
}
// 洗牌
static void shufflePlaylist(void) {
    if (shuffle_order == NULL) {
        shuffle_order = (int *)malloc(music_files_count * sizeof(int));
    }

    for (int i = 0; i < music_files_count; i++) {
        shuffle_order[i] = i;
    }
    for (int i = music_files_count - 1; i > 0; i--) {
        int j = rand() % (i + 1);
        int temp = shuffle_order[i];
        shuffle_order[i] = shuffle_order[j];
        shuffle_order[j] = temp;
    }
    printf("shuffle: ");
    for (int i = 0; i < music_files_count; i++) {
        printf("%d, ", shuffle_order[i]);
    }
    printf("\b\n");
}
// 下一首, 上一首, 点击列表播放之类的, 同样需要做的UI更新
static void changeMusicUpdateUI(void) {
    // 暂停定时器
    lv_timer_pause(progressTimer);
    // 重置进度条
    lv_bar_set_value(ui_Progress_Slider, 0, LV_ANIM_OFF);
    lv_label_set_text(ui_Current_Time, "00:00:00");
    lv_label_set_text(ui_Total_Time, "00:00:00");

    playing = true;
    lv_img_set_src(ui_Play_Pause_Icon, &ui_img_899744137);
}
// 当播放完毕后下一首的任务
static void music_play_mode_task(void *pvParameter) {
    while (1) {
        xEventGroupWaitBits(bt_event_group, EVENT_END_PLAY, pdTRUE, pdFALSE, portMAX_DELAY);
        nextTrack(NULL);
    }
}

// 关闭"tf卡未插入"的弹窗的回调
static void close_tf_card_notfound_msg_timer_callback(lv_timer_t *timer) {
    lv_async_call([](void *param) {
       lv_obj_add_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
    }, nullptr);
    lv_timer_pause(close_tf_card_notfound_msg_timer);
}

// 关闭音量调节块的回调
static void close_volume_adjust_timer_callback(lv_timer_t *timer) {
    lv_async_call([](void *param) {
        lv_obj_add_flag(current_screen_volume_adjust, LV_OBJ_FLAG_HIDDEN);
    }, nullptr);
    lv_timer_pause(close_volume_adjust_timer);
}

//////////////////// lvgl事件回调 ////////////////////

// ******************** initial actions ********************

// 设置用于堆跟踪的记录容量
#define TRACE_RECORDS 100
static heap_trace_record_t trace_records[TRACE_RECORDS];

// 除了这个, 还有各个init[****]Settings函数也在initital actions
void initActions(lv_event_t *e) {
    esp_err_t err = heap_trace_init_standalone(trace_records, TRACE_RECORDS);
    if (err != ESP_OK) {
        ESP_LOGE("HEAP_TRACE", "Heap trace init failed: %d", err);
    }
        // 等待上电的主动返回值被丢掉
        // xEventGroupWaitBits(bt_event_group, EVENT_STARTUP_SUCCESS, pdTRUE, pdFALSE, portMAX_DELAY);

    // 如果esp32崩溃重启, 蓝牙模块是不重启的, 不可能再拿到这个事件位, 因此这里不等待这个事件位
    // 所以这个事件位暂时用于设置蓝牙名称后, 自动复位的蓝牙模块的完成消息, 所以在这里clear掉
    xEventGroupClearBits(bt_event_group, EVENT_STARTUP_SUCCESS);
    // vTaskDelay(1000 / portTICK_PERIOD_MS);

    inactive_timer = lv_timer_create(inactive_callback, INACTIVE_TIME, NULL);
    lv_timer_pause(inactive_timer);

    close_tf_card_notfound_msg_timer = lv_timer_create(close_tf_card_notfound_msg_timer_callback, 2000, NULL);

    delay_update_alarm_clock_timer = lv_timer_create(delay_update_alarm_clock_time_callback, 300, NULL);

    close_volume_adjust_timer = lv_timer_create(close_volume_adjust_timer_callback, 2000, NULL);

    init_phase_semaphore = xSemaphoreCreateBinary();
    if (init_phase_semaphore == NULL) {
        ESP_LOGE("initActions", "创建信号量失败");
    }
    vTaskDelay(500 / portTICK_PERIOD_MS);
    ESP_LOGI("LVGL initActions", "这条消息之上应该是四条返回值");
    // 查询设备状态
    AT_MV();
    // 关闭提示音
    AT_CN(1);

    xSemaphoreGive(init_phase_semaphore);

    if (device_state == 2) {
        // 只要识别到卡就试图初始化音乐列表
        create_music_item();

        init_durations_for_nvs();
    } else {
        ESP_LOGW("initActions", "未识别到TF卡");
    }

    // 设置待机界面的日期label, 只能写在这了, 毕竟日期就这个地方会显示
    set_date_label(ui_Idle_Window_Date);
    // 设置待机screen, 为了不让多余的文件include "ui_events.h"只好这么写了
    idle_window = ui_Idle_Window;
    // clear主动返回的QV, 保证主动查询时都能被阻塞
    xEventGroupClearBits(bt_event_group, EVENT_QUERY_VERSION);
    // 设置版本号
    AT_QV();
    lv_label_set_text(ui_System_Version_Text, final_version);

    // 默认选择自然均衡器
    select_eq_nature(NULL);

}

// ******************** 各界面加载完成后的回调 ********************
// 各个screen loaded时, 将screen的时间label设置为time_label上, 保持全局时间显示, Settings界面没有这东西

void mainScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Main_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Main_Header_Volume;
    current_screen_volume_adjust = ui_Main_Window_Volume_adjust;
    current_screen_on_screen_range = ui_On_Main_Screen_Range;
    update_header_volume();

    // 每次到主界面时, 重建一个待机定时器, 因为只有在主界面时才会试图进入待机模式
    create_enter_idle_timer(enter_idle_time_level_to_second(enter_idle_time_level));
    // 停止不活动定时器
    del_inactive_timer();
}
void musicScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Music_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Music_Header_Volume;
    current_screen_volume_adjust = ui_Music_Window_Volume_adjust;
    current_screen_on_screen_range = ui_Music_On_Screen_Range;
    update_header_volume();

    // 许多东西都不能写这里, 因为play界面也能进入music界面, 不知可以从main进入music, 所以许多东西要写在leaveMainWindow里
}
void musicPlayScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Music_Time2);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Music_Play_Header_Volume;
    current_screen_volume_adjust = ui_Music_Play_Window_Volume_adjust;
    current_screen_on_screen_range = ui_Music_Play_On_Screen_Range;
    update_header_volume();
}
void natureSoundScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Nature_Sound_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Nature_Header_Volume;
    current_screen_volume_adjust = ui_Nature_Window_Volume_adjust;
    current_screen_on_screen_range = ui_Nature_On_Screen_Range;
    update_header_volume();

    open_living_room_channel();
}
void bluetoothScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Bluetooth_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Bluetooth_Header_Volume;
    current_screen_volume_adjust = ui_Bluetooth_Window_Volume_adjust;
    update_header_volume();

    // 进入蓝牙模式, 需要播放提示音
    open_living_room_channel();
    AT_CN(0);
    AT_CM(1);
    bluetooth_state = 1;    // 等待连接

    // 开启任务, 监听蓝牙
    if (bluetooth_monitor_state_task_handle == NULL) {
        xTaskCreate(bluetooth_monitor_state_task, "bluetooth_monitor_state_task", 4096, NULL, 5,
                    &bluetooth_monitor_state_task_handle);
    } else {
        ESP_LOGE("bluetoothScrLoaded", "这不可能");
    }
}
void modeScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Mode_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Mode_Header_Volume;
    current_screen_volume_adjust = ui_Mode_Window_Volume_adjust;
    update_header_volume();
}
void wakeupScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Wake_up_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Wakeup_Header_Volume;
    current_screen_volume_adjust = ui_Wakeup_Window_Volume_adjust;
    update_header_volume();

    // 如果现在没有已设置的闹钟, 则将闹钟时间调整到当前时间
    if (alarm_clock_itself_timer == NULL) {
        struct tm *local_time = localtime(&global_time);
        alarm_clock_selected_hour = local_time->tm_hour;
        alarm_clock_selected_min = local_time->tm_min;
        delay_update_alarm_clock_time_callback(NULL);   // 调用这个, 只是借用一下
        lv_roller_set_selected(ui_alarm_clock_hour_roller, alarm_clock_selected_hour, LV_ANIM_OFF);
        lv_roller_set_selected(ui_alarm_clock_min_roller, alarm_clock_selected_min, LV_ANIM_OFF);
    }
    // 为了预览铃声, 预先保证在音乐模式
    if (work_mode != 2) {
        AT_CM(2);
        vTaskDelay(300 / portTICK_PERIOD_MS);
    }
}
void guideScrLoaded(lv_event_t *e) {
    set_time_label(ui_Header_Guide_Time);
    if (global_time > 0) update_current_time_label(true);
    current_screen_header_volume = ui_Guide_Header_Volume;
    current_screen_volume_adjust = ui_Guide_Window_Volume_adjust;
    update_header_volume();

    // 指南界面时, 不进入待机状态, 所以停止定时器
    // ...
}
void idleScrLoaded(lv_event_t *e) {
    set_time_label(ui_Idle_Window_Time);
    if (global_time > 0) update_current_time_label(true);
}
void settingsScrLoaded(lv_event_t *e) {
    // 写的什么b, 只能写这了
    lv_obj_add_flag(ui_PleaseRestartMsgPanel, LV_OBJ_FLAG_HIDDEN);
}
// ******************** 离开各界面后的回调 ********************

void leaveMainWindow(lv_event_t *e) {
    // 关闭待机定时器, 因为只有处于主界面时才会试图定时以进入待机界面
    del_enter_idle_timer();

    closeVolumeAdjust(NULL);
    // 处理特殊界面
    lv_obj_t *new_scr = lv_scr_act();
    // 进入Idle界面即正常待机
    if (new_scr == ui_Idle_Window) {
        printf("Enter Idle Window\n");
    }
    // 只有从main进入music界面才打开某些东西(因为play界面也能进入music界面)
    else if (new_scr == ui_Music_Window) {
        AT_CM(2);

        assert(music_play_task_handle == NULL);
        xTaskCreate(music_play_mode_task, "music_play_mode_task", 4096, NULL, 5, &music_play_task_handle);
        if (bath_play_task_handle != NULL) {
            AT_AA0();
            vTaskDelete(bath_play_task_handle);
            bath_play_task_handle = NULL;
            lv_async_call(hide_bath_sound_icon_callback, NULL);
        }
    }
    // 自然之音只是打开音乐模式
    else if (new_scr == ui_Nature_Sound_Window) {
        AT_CM(2);
        create_inactive_timer();
    }
    // 设置界面不创建不活动定时器
    else if (new_scr == ui_Settings_Window) {

    }
    // 通常都创建不活动定时器, 无操作一定时间后回到主界面
    else {
        printf("别的界面, 创建不活动定时器\n");
        create_inactive_timer();
    }
}
void leaveMusicWindow(lv_event_t *e) {
    printf("Leave Music\n");
    lv_obj_t *currentScreen = lv_scr_act();
    // 只有从music界面离开至main界面才关闭功放与停止音乐(因为music界面也能进入play界面)
    if (currentScreen == ui_Main_Window) {
        assert(music_play_task_handle != NULL);
        vTaskDelete(music_play_task_handle);
        music_play_task_handle = NULL;

        ESP_LOGI("leaveMusicWindow", "退出音乐库");
        // 如果闹钟准备响, 就不操作这两个
        if (!alarm_clock_ready_shouting) {
            AT_CL(0);
            AT_CM(0);
        }

        lv_timer_pause(progressTimer);

        // 关闭当前音乐名高亮
        if (current_playing_music_obj != NULL) {
            lv_obj_clear_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
            current_playing_music_obj = NULL;
        }
    }
}
void leaveMusicPlayWindow(lv_event_t * e) {
    printf("Leave Music Play\n");
}
void leaveNatureSoundWindow(lv_event_t *e) {
    printf("Leave Nature\n");
    // 主动或自动退出自然之音界面时, 关闭功放并进入空闲模式, 闹钟除外
    if (!alarm_clock_ready_shouting) {
        AT_CL(0);
        AT_CM(0);
    }

    if (nature_play_task_handle != NULL) {
        vTaskDelete(nature_play_task_handle);
        nature_play_task_handle = NULL;
    }

    // 图标恢复
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);
}
void leaveBlutoothWindow(lv_event_t *e) { 
    // xTaskCreate(cleanBluetoothTask, "cleanBluetoothTask", 4096, NULL, 5, NULL);
    // 进入空闲模式
    if (!alarm_clock_ready_shouting) {
        AT_CM(0);
        AT_CL(0);
    }
    // 关闭提示音以防止进音乐模式时播放"tf卡模式"
    AT_CN(1);
    // 删除蓝牙状态监听任务
    if (bluetooth_monitor_state_task_handle != NULL) {
        vTaskDelete(bluetooth_monitor_state_task_handle);
        bluetooth_monitor_state_task_handle = NULL;
    }
    // 删除浴室播放任务
    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
        lv_async_call(hide_bath_sound_icon_callback, NULL);
    }
}
void leaveModeWindow(lv_event_t *e) {

}
void leaveWakeupWindow(lv_event_t *e) {
    cancel_save_alarm_clock(NULL);
    lv_obj_add_flag(ui_Ringtone_Select, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_AlarmClockTime, LV_OBJ_FLAG_HIDDEN);
    cancel_preview_ringtone(NULL);

    if (work_mode == 2 && !alarm_clock_ready_shouting) {
        AT_CM(0);
        AT_CL(0);
    }

    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
        lv_async_call(hide_bath_sound_icon_callback, NULL);
        ESP_LOGI("leaveWakeupWindow", "已关闭浴室音乐");
    }
    assert(music_play_task_handle == NULL && bath_play_task_handle == NULL && nature_play_task_handle == NULL);
}
void leaveGuideWindow(lv_event_t *e) {

}
void leaveSettingsWindow(lv_event_t *e) {
    lv_obj_add_flag(ui_Volume_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_Backlight_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_System_Settings_Panel, LV_OBJ_FLAG_HIDDEN);
    if (!(lv_scr_act() == ui_Settings_Wifi_Window) && !(lv_scr_act() == ui_Settings_Time_Window) && !(lv_scr_act() == ui_Settings_Bluetooth_Window)) {
        lv_obj_clear_flag(ui_System_Password, LV_OBJ_FLAG_HIDDEN);
        lv_textarea_set_text(ui_System_Password_Text, "");
    }
}
// ******************** 背光与待机相关 ********************

// 初始化背光亮度与待机时间, 以及创建待机定时器
void initBacklightSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to open NVS");
        return;
    }

    err = nvs_get_u32(nvs_handle, "level", &backlight_level);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("backlightSettings", "NVS中未找到'level', 将写入默认值 %ld", backlight_level);
        err = nvs_set_u32(nvs_handle, "level", backlight_level);
        if (err != ESP_OK) {
            ESP_LOGE("backlightSettings", "Failed to set default value for 'level': %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to get 'level' from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);

    err = nvs_get_u32(nvs_handle, "time", &enter_idle_time_level);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("backlightSettings", "NVS中未找到'time'，将写入默认值 %ld", enter_idle_time_level);
        err = nvs_set_u32(nvs_handle, "time", enter_idle_time_level);
        if (err != ESP_OK) {
            ESP_LOGE("backlightSettings", "Failed to set default value for 'time': %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("backlightSettings", "Failed to get 'time' from NVS: %s", esp_err_to_name(err));
    }
    // 麻烦的off, 这行就像lv_label_set_text_fmt的用处
    set_enter_idle_time_to_label(ui_Enter_Idle_Time_Value, enter_idle_time_level);
    nvs_close(nvs_handle);
}
// 确认保存背光设置
void saveBacklightSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to open NVS");
        return;
    }

    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    backlight_level = atoi(text);
    err = nvs_set_u32(nvs_handle, "level", backlight_level);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to set backlight_level in NVS");
        nvs_close(nvs_handle);
        return;
    }

    const char *second = lv_label_get_text(ui_Enter_Idle_Time_Value);
    enter_idle_time_level = enter_idle_time_second_to_level(atoi(second));

    err = nvs_set_u32(nvs_handle, "time", enter_idle_time_level);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightTime", "Failed to set backlightTime in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveBacklightSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
}
// 不保存背光设置
void cancelSaveBacklightSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);
    set_backlight(backlight_level);
    set_enter_idle_time_to_label(ui_Enter_Idle_Time_Value, enter_idle_time_level);
}
// 增加背光亮度
void addBrightness(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    int brightnessLevel = atoi(text);
    brightnessLevel = (brightnessLevel < 5) ? brightnessLevel + 1 : 5;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%d", brightnessLevel);
    set_backlight(brightnessLevel);
}
// 减少背光亮度
void decBrightness(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Backlight_Brightness_Value);
    int brightnessLevel = atoi(text);
    brightnessLevel = (brightnessLevel > 1) ? brightnessLevel - 1 : 1;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%d", brightnessLevel);
    set_backlight(brightnessLevel);
}
// 增加待机时间
void addBacklightTime(lv_event_t *e) {
    const char *second = lv_label_get_text(ui_Enter_Idle_Time_Value);
    int enter_idle_time_level = enter_idle_time_second_to_level(atoi(second));

    if (enter_idle_time_level < 6) enter_idle_time_level++;

    set_enter_idle_time_to_label(ui_Enter_Idle_Time_Value, enter_idle_time_level);
}
// 减少待机时间
void decBacklightTime(lv_event_t *e) {
    const char *second = lv_label_get_text(ui_Enter_Idle_Time_Value);
    // atoi("off")会返回0, 可以利用
    int enter_idle_time_level = enter_idle_time_second_to_level(atoi(second));

    if (enter_idle_time_level > 0) enter_idle_time_level--;

    set_enter_idle_time_to_label(ui_Enter_Idle_Time_Value, enter_idle_time_level);
}
// 485指令睡眠模式所用
void sleep_mode(void) {
    // 固定关闭背光
    set_backlight(0);
    // 如果处于音乐库或音乐播放或自然之音界面, 就不返回主界面, 而是放出唤醒Range
    if (lv_scr_act() == ui_Music_Play_Window || lv_scr_act() == ui_Music_Window || lv_scr_act() == ui_Nature_Sound_Window) {
        lv_obj_clear_flag(current_screen_on_screen_range, LV_OBJ_FLAG_HIDDEN);
    } else {
        // 如果处理睡眠指令时, 处于非播放界面, 就跑到Idle界面来处理, 真是乱套了
        lv_scr_load(ui_Idle_Window);
        lv_obj_add_flag(ui_Off_Screen_Btn, LV_OBJ_FLAG_HIDDEN);
    }
}

// 按下待机界面上的熄屏按钮主动进入熄屏
void offScreen(lv_event_t *e) {
    printf("熄屏\n");
    // 熄屏实际上仍然在idle界面, 只是关了背光
    set_backlight(0);
    // 防止想要醒来但再次按到熄屏按钮, 所以把它隐藏掉
    lv_obj_add_flag(ui_Off_Screen_Btn, LV_OBJ_FLAG_HIDDEN);
}
// 稍微逆天
static void wake_set_bl(void *param) {
    vTaskDelay(160 / portTICK_PERIOD_MS);
    set_backlight(backlight_level);
    vTaskDelete(NULL);
}
// 从熄屏中醒来, 同时485指令明亮模式也调用这个
void onScreen(lv_event_t *e) {
    printf("Wake up\n");
    // 如果熄屏时在这几个界面, 说明并不想要醒到主界面
    if (lv_scr_act() == ui_Music_Window || lv_scr_act() == ui_Music_Play_Window || lv_scr_act() == ui_Nature_Sound_Window) {
        set_backlight(backlight_level);
        lv_obj_add_flag(current_screen_on_screen_range, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_scr_load(ui_Main_Window);
        // 等主界面load完了再打开背光
        xTaskCreate(wake_set_bl, "wake_set_bl", 1024, NULL, 5, NULL);
        lv_obj_clear_flag(ui_Off_Screen_Btn, LV_OBJ_FLAG_HIDDEN);
    }
}


// ******************** 蓝牙相关 ********************

// 更改蓝牙设置
static void bluetooth_cfg_task(void *pvParameter) {
    AT_BE(bluetooth_ui_pass);
    AT_BD(bluetooth_ui_name);
    bluetooth_sync_cfg();
    vTaskDelete(NULL);
}
// 将蓝牙的真实配置读到这边的界面上来
static void bluetooth_sync_cfg(void) {
    AT_CM(1);
    AT_TD();
    AT_TE();
    AT_CM(0);
    strncpy(bluetooth_ui_name, bluetooth_name, sizeof (bluetooth_ui_name));
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    lv_label_set_text(ui_Bluetooth_Name_Value, bluetooth_ui_name);

    strncpy(bluetooth_ui_pass, bluetooth_password, sizeof (bluetooth_ui_pass));
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
    lv_label_set_text(ui_Bluetooth_Password_Value, bluetooth_ui_pass);
}

// 初始化蓝牙设置
void initBluetoothSettings(lv_event_t *e) {
    if (xSemaphoreTake(init_phase_semaphore, portMAX_DELAY) == pdTRUE) {
        // 读nvs, 查看蓝牙名称是否已经初始化过了
        nvs_handle_t nvs_handle;
        esp_err_t err = nvs_open("bluetoothCfg", NVS_READWRITE, &nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("initBluetoothSettings", "Failed to open NVS");
            return;
        }
        uint8_t is_inited = 0;
        err = nvs_get_u8(nvs_handle, "isInited", &is_inited);
        if (err == ESP_ERR_NVS_NOT_FOUND) {
            ESP_LOGW("initBluetoothSettings", "NVS中未找到'isInited', 将进行蓝牙名称初始化");
            // 将它设为已初始化的状态
            err = nvs_set_u8(nvs_handle, "isInited", 1);
            if (err != ESP_OK) {
                ESP_LOGE("initBluetoothSettings", "Failed to set isInited in NVS: %s", esp_err_to_name(err));
            } else {
                nvs_commit(nvs_handle);
            }
        } else if (err != ESP_OK) {
            ESP_LOGE("initBluetoothSettings", "Failed to get isInited from NVS: %s", esp_err_to_name(err));
        }
        nvs_close(nvs_handle);

        // 如果已经初始化过, 就进入正常的同步信息环节, 否则进行初始化
        if (is_inited) {
            bluetooth_sync_cfg();
        } else {
            uint8_t mac[6];
            esp_read_mac(mac, ESP_MAC_WIFI_STA);
            int combined = (mac[4] % 100) * 100 + (mac[5] % 100); // 将两个字节组合成四位数字
            snprintf(bluetooth_ui_name, sizeof(bluetooth_ui_name), "BT-%04d", combined); // 使用四位数字格式
            lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
            
            snprintf(bluetooth_ui_pass, sizeof(bluetooth_ui_pass), "%d", 8888);
            lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
            xTaskCreate(bluetooth_cfg_task, "bluetooth_cfg_task", 4096, NULL, 5, NULL);
            vTaskDelay(3000 / portTICK_PERIOD_MS);  // 等待蓝牙复位
            ESP_LOGI("verifyResetFactory", "蓝牙设置重置为name: %s, pass: %s", bluetooth_ui_name, bluetooth_ui_pass);
        }
        xSemaphoreGive(init_phase_semaphore);
    }
}
// 确认保存蓝牙设置
void saveBluetoothSetting(lv_event_t *e) {
    const char *name = lv_textarea_get_text(ui_Bluetooth_Name_Input2);
    strncpy(bluetooth_ui_name, name, sizeof(bluetooth_ui_name));
    bluetooth_ui_name[sizeof(bluetooth_ui_name) - 1] = '\0';
    
    const char *password = lv_textarea_get_text(ui_Bluetooth_Password_Input2);
    strncpy(bluetooth_ui_pass, password, sizeof(bluetooth_ui_pass));
    bluetooth_ui_pass[sizeof(bluetooth_ui_pass) - 1] = '\0';

    xTaskCreate(bluetooth_cfg_task, "bluetooth_cfg_task", 4096, NULL, 5, NULL);
}
// 不保存蓝牙设置
void cancelSaveBluetoothSetting(lv_event_t *e) {
    // 改完蓝牙设置后没点保存就退出界面, 就把原先的值设回来, 因为是textarea
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);
}

// ******************** 时间相关 ********************

// 确认保存时间与日期
void saveTimeSetting(lv_event_t *e) {
    // 检查时间输入
    const char *hour_text = lv_textarea_get_text(ui_Time_Setting_Hour2);
    const char *min_text = lv_textarea_get_text(ui_Time_Setting_Min2);
    int hour = atoi(hour_text);
    int min = atoi(min_text);
    if (hour < 0 || hour > 23 || min < 0 || min > 59) {
        char hour_text[3];
        snprintf(hour_text, sizeof(hour_text), "%02ld", time_hour);
        lv_textarea_set_text(ui_Time_Setting_Hour2, hour_text);
        char min_text[3];
        snprintf(min_text, sizeof(min_text), "%02ld", time_min);
        lv_textarea_set_text(ui_Time_Setting_Min2, min_text);
        ESP_LOGE("saveTimeSetting", "Invalid input: hour=%s, minute=%s", hour_text, min_text);
        return;
    }
    time_hour = hour;
    time_min = min;
    // 检查日期输入
    const char *year_text = lv_textarea_get_text(ui_Date_Setting_Year2);
    const char *month_text = lv_textarea_get_text(ui_Date_Setting_Month2);
    const char *day_text = lv_textarea_get_text(ui_Date_Setting_Day2);
    uint32_t year = (uint32_t)atoi(year_text);
    uint32_t month = (uint32_t)atoi(month_text);
    uint32_t day = (uint32_t)atoi(day_text);
    if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        char year_text[5];
        snprintf(year_text, sizeof(year_text), "%ld", date_year);
        lv_textarea_set_text(ui_Date_Setting_Year2, year_text);
        char month_text[3];
        snprintf(month_text, sizeof(month_text), "%02ld", date_month);
        lv_textarea_set_text(ui_Date_Setting_Month2, month_text);
        char day_text[3];
        snprintf(day_text, sizeof(day_text), "%02ld", date_day);
        lv_textarea_set_text(ui_Date_Setting_Day2, day_text);
        ESP_LOGE("saveDateSetting", "Invalid input: year=%s, month=%s, day=%s", year_text, month_text, day_text);
        return;
    }
    date_year = year;
    date_month = month;
    date_day = day;
    global_time = convertToTimestamp(date_year, date_month, date_day, time_hour, time_min);
    if (update_time_task_handle == NULL) {
        xTaskCreate(update_time_task, "updateTimeTask", 2048, NULL, 5, &update_time_task_handle);
    }
    
    struct timeval now = {
        .tv_sec = global_time,
        .tv_usec = 0
    };
    settimeofday(&now, NULL);
}
// 不保存时间设置
void cancelSaveTimeSettings(lv_event_t *e) {
    // 转换时间小时为字符串并设置文本区域
    char hour_str[3];  // 假设小时不会超过两位数
    snprintf(hour_str, sizeof(hour_str), "%02ld", time_hour);
    lv_textarea_set_text(ui_Time_Setting_Hour2, hour_str);

    // 转换时间分钟为字符串并设置文本区域
    char min_str[3];  // 假设分钟不会超过两位数
    snprintf(min_str, sizeof(min_str), "%02ld", time_min);
    lv_textarea_set_text(ui_Time_Setting_Min2, min_str);

    // 转换日期年份为字符串并设置文本区域
    char year_str[5];  // 假设年份最多四位数
    snprintf(year_str, sizeof(year_str), "%ld", date_year);
    lv_textarea_set_text(ui_Date_Setting_Year2, year_str);

    // 转换日期月份为字符串并设置文本区域
    char month_str[3];  // 假设月份不会超过两位数
    snprintf(month_str, sizeof(month_str), "%02ld", date_month);
    lv_textarea_set_text(ui_Date_Setting_Month2, month_str);

    // 转换日期天数为字符串并设置文本区域
    char day_str[3];  // 假设日期不会超过两位数
    snprintf(day_str, sizeof(day_str), "%02ld", date_day);
    lv_textarea_set_text(ui_Date_Setting_Day2, day_str);
}
// ******************** 声音相关 ********************

static void volume_timer_callback(TimerHandle_t xTimer);
// 初始化默认音量与最大音量与浴室播放通道
void initVolumeSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to open NVS");
        return;
    }
    // 读取 defaultVolume
    err = nvs_get_u32(nvs_handle, "defaultVolume", &defaultVolume);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'defaultVolume', 将写入默认值 %ld", defaultVolume);
        err = nvs_set_u32(nvs_handle, "defaultVolume", defaultVolume);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set defaultVolume in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get defaultVolume from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    current_volume = defaultVolume;

    volume_timer = xTimerCreate("VolumeTimer", pdMS_TO_TICKS(100), pdFALSE, NULL, volume_timer_callback);
    // 同步音量显示和实际
    if (xSemaphoreTake(init_phase_semaphore, portMAX_DELAY) == pdTRUE) {
        volume_timer_callback(NULL);
        xSemaphoreGive(init_phase_semaphore);
    }

    // 读取 maxVolume
    err = nvs_get_u32(nvs_handle, "maxVolume", &maxVolume);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'maxVolume', 将写入默认值 %ld", maxVolume);
        err = nvs_set_u32(nvs_handle, "maxVolume", maxVolume);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set maxVolume in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get maxVolume from NVS: %s", esp_err_to_name(err));
    }
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);

    // 读取 bathChannel
    err = nvs_get_u32(nvs_handle, "bathChannel", &bath_channel_bit);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGW("initVolumeSettings", "NVS中未找到'bathChannel', 将写入默认值 %ld", bath_channel_bit);
        err = nvs_set_u32(nvs_handle, "bathChannel", bath_channel_bit);
        if (err != ESP_OK) {
            ESP_LOGE("initVolumeSettings", "Failed to set bathChannel in NVS: %s", esp_err_to_name(err));
        } else {
            nvs_commit(nvs_handle);
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initVolumeSettings", "Failed to get bathChannel from NVS: %s", esp_err_to_name(err));
    }
    nvs_close(nvs_handle);
    switch (bath_channel_bit) {
        case 0:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 1:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 2:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 3:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
    }

    
}
// 增加默认音量
void addDefaultVolume(lv_event_t *e) {
    // 如果默认音量试图比最大音量高, 拒绝
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);

    if (tmp_default_volume >= tmp_max_volume) {
        return;
    }
    tmp_default_volume = (tmp_default_volume < 15) ? tmp_default_volume + 1 : 15;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
}
// 减少默认音量
void decDefaultVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);
    tmp_default_volume = (tmp_default_volume > 1) ? tmp_default_volume - 1 : 1;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
}
// 增加最大音量
void addMaxVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    tmp_max_volume = (tmp_max_volume < 15) ? tmp_max_volume + 1 : 15;
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%d", tmp_max_volume);
}
// 减少最大音量
void decMaxVolume(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_Max_Volume_Value);
    int tmp_max_volume = atoi(text);
    tmp_max_volume = (tmp_max_volume > 1) ? tmp_max_volume - 1 : 1;
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%d", tmp_max_volume);

    // 如果最大音量比默认音量还低, 就顺便把默认音量也减少
    text = lv_label_get_text(ui_Default_Volume_Value);
    int tmp_default_volume = atoi(text);
    if (tmp_default_volume > tmp_max_volume) {
        tmp_default_volume--;
        lv_label_set_text_fmt(ui_Default_Volume_Value, "%d", tmp_default_volume);
    }
}
// 确认保存音量设置
void saveVolumeSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to open NVS");
        return;
    }
    // 默认音量
    const char *text = lv_label_get_text(ui_Default_Volume_Value);
    defaultVolume = atoi(text);
    err = nvs_set_u32(nvs_handle, "defaultVolume", defaultVolume);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to set defaultVolume in NVS");
        nvs_close(nvs_handle);
        return;
    }
    // 最大音量
    text = lv_label_get_text(ui_Max_Volume_Value);
    maxVolume = atoi(text);
    err = nvs_set_u32(nvs_handle, "maxVolume", maxVolume);
    if (err != ESP_OK) {
        ESP_LOGE("saveMaxVolume", "Failed to set maxVolume in NVS");
        nvs_close(nvs_handle);
        return;
    }
    if (current_volume > maxVolume) {
        current_volume = maxVolume;
    }
    update_header_volume();
    volume_timer_callback(NULL);
    // 浴室通道
    bool left_switch_checked = lv_obj_get_state(ui_Bath_Play_Left_Channel_Switch) & LV_STATE_CHECKED;
    bool right_switch_checked = lv_obj_get_state(ui_Bath_Play_Right_Channel_Switch) & LV_STATE_CHECKED;

    if (left_switch_checked && right_switch_checked) {
        bath_channel_bit = 3;
    } else if (left_switch_checked && !right_switch_checked) {
        bath_channel_bit = 2;
    } else if (!left_switch_checked && right_switch_checked) {
        bath_channel_bit = 1;
    } else {
        bath_channel_bit = 0;
    }
    err = nvs_set_u32(nvs_handle, "bathChannel", bath_channel_bit);
    if (err != ESP_OK) {
        ESP_LOGE("saveBathChannel", "Failed to set saveBathChannel in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveVolumeSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
    // 如果在播放浴室音乐就即时更改通道, 音乐库和自然之音则不可能在播放时还能在设置界面
    if (bath_play_task_handle != NULL) {
        open_bath_channel();
    }
}
// 不保存声音设置
void cancelSaveVolumeSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);
    switch (bath_channel_bit) {
        case 0:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 1:
            lv_obj_clear_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 2:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_clear_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
        case 3:
            lv_obj_add_state(ui_Bath_Play_Left_Channel_Switch, LV_STATE_CHECKED);
            lv_obj_add_state(ui_Bath_Play_Right_Channel_Switch, LV_STATE_CHECKED);
            break;
    }
}
// 打开音量调节块
void openVolumeAdjust(lv_event_t *e) {
    lv_obj_clear_flag(current_screen_volume_adjust, LV_OBJ_FLAG_HIDDEN);
    lv_timer_reset(close_volume_adjust_timer);
    lv_timer_resume(close_volume_adjust_timer);
}
// 关闭音量调节块
void closeVolumeAdjust(lv_event_t * e) {
    lv_obj_add_flag(current_screen_volume_adjust, LV_OBJ_FLAG_HIDDEN);
}
// 改变音量
static void volume_timer_callback(TimerHandle_t xTimer) {
    // AT_CA(current_volume * 2);
    AT_CA(current_volume);
}
void changeVolume(lv_event_t * e) {
    lv_obj_t * slider = lv_event_get_target(e); // 获取触发事件的对象
    int value = lv_slider_get_value(slider); // 获取滑块的值
    printf("Slider value: %d\n", value);

    current_volume = (value * maxVolume) / MAX_VOLUME_LIMIT / 2;
    update_header_volume();
    xTimerReset(volume_timer, 0);
    lv_timer_reset(close_volume_adjust_timer);
}


// ******************** 系统相关 ********************

// 初始化系统设置
void initSystemSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initSystemSettings", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    // 读取 ID
    err = nvs_get_u32(nvs_handle, "ID", &system_id);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        system_id = 0;
        ESP_LOGW("initSystemSettings", "NVS中未找到'ID', 将写入默认值 %ld", system_id);
        err = nvs_set_u32(nvs_handle, "ID", system_id);
        if (err != ESP_OK) {
            ESP_LOGE("initSystemSettings", "Failed to set default ID in NVS: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_commit(nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("initSystemSettings", "Failed to commit NVS changes: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initSystemSettings", "Failed to get ID from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);
    nvs_close(nvs_handle);
}
// 确认保存系统设置
void saveSystemSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to open NVS");
        return;
    }

    const char *text = lv_label_get_text(ui_System_ID_Value);
    system_id = atoi(text);

    err = nvs_set_u32(nvs_handle, "ID", system_id);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to set ID in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveIDSetting", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);
}
// 不保存系统设置
void cancelSaveSystemSettings(lv_event_t *e) {
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);
}
// 增加ID
void addID(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_System_ID_Value);
    int id = atoi(text);
    id = (id < 7) ? id + 1 : 7;
    lv_label_set_text_fmt(ui_System_ID_Value, "%d", id);
}
// 减少ID
void decID(lv_event_t *e) {
    const char *text = lv_label_get_text(ui_System_ID_Value);
    int id = atoi(text);
    id = (id > 0) ? id - 1 : 0;
    lv_label_set_text_fmt(ui_System_ID_Value, "%d", id);
}
// 确认恢复出厂设置
void verifyResetFactory(lv_event_t *e)
{
    // 擦除 NVS
    esp_err_t err = nvs_flash_erase();
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "NVS擦除失败: %s", esp_err_to_name(err));
        return;
    } else {
        ESP_LOGI("verifyResetFactory", "NVS擦除成功");
    }
    // return;
    // 初始化nvs
    err = nvs_flash_init();
    if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        err = nvs_flash_init();
    }
    if (err == ESP_OK) {
        ESP_LOGI("verifyResetFactory", "NVS初始化成功");
    } else {
        ESP_LOGE("verifyResetFactory", "NVS初始化失败: %s", esp_err_to_name(err));
        return;
    }

    nvs_handle_t nvs_handle;

    // 重置所有nvs设置

    // 重置背光设置
    err = nvs_open("BLSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_bk_level = 3;
    uint32_t new_bk_time_level = 4;
    err = nvs_set_u32(nvs_handle, "level", new_bk_level);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'level': %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "time", new_bk_time_level);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'time': %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "背光设置重置为level: %ld, time: %ld", new_bk_level, new_bk_time_level);
    }
    nvs_close(nvs_handle);

    backlight_level = new_bk_level;
    enter_idle_time_level = new_bk_time_level;
    lv_label_set_text_fmt(ui_Backlight_Brightness_Value, "%ld", backlight_level);
    set_backlight(backlight_level);
    set_enter_idle_time_to_label(ui_Enter_Idle_Time_Value, enter_idle_time_level);


    // 重置声音设置
    err = nvs_open("VolumeCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_default_volume = 8;
    uint32_t new_max_volume = 15;
    uint32_t new_bath_channel = 2; 
    err = nvs_set_u32(nvs_handle, "defaultVolume", new_default_volume);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set defaultVolume: %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "maxVolume", new_max_volume);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set maxVolume: %s", esp_err_to_name(err));
    }
    err = nvs_set_u32(nvs_handle, "bathChannel", new_bath_channel);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set bathChannel: %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "声音设置重置为default: %ld, max: %ld, bathChannel: %ld", new_default_volume, new_max_volume, new_bath_channel);
    }
    nvs_close(nvs_handle);

    defaultVolume = new_default_volume;
    maxVolume = new_max_volume;
    bath_channel_bit = new_bath_channel;
    lv_label_set_text_fmt(ui_Default_Volume_Value, "%ld", defaultVolume);
    lv_label_set_text_fmt(ui_Max_Volume_Value, "%ld", maxVolume);


    // 重置ID
    err = nvs_open("SystemSettings", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint32_t new_id = 0;
    err = nvs_set_u32(nvs_handle, "ID", new_id);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default ID: %s", esp_err_to_name(err));
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes: %s", esp_err_to_name(err));
    } else {
        ESP_LOGI("verifyResetFactory", "ID重置为 %ld", new_id);
    }
    nvs_close(nvs_handle);
    system_id = new_id;
    lv_label_set_text_fmt(ui_System_ID_Value, "%ld", system_id);


    // 重置WiFi设置
    err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    uint8_t new_enabled = 0;
    char new_wifi_ssid[] = "12345678";
    char new_wifi_password[] = "12345678";
    err = nvs_set_u8(nvs_handle, "enabled", new_enabled);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set default value for 'enabled': %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_set_str(nvs_handle, "name", new_wifi_ssid);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set name in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_set_str(nvs_handle, "password", new_wifi_password);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to set password in NVS");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("verifyResetFactory", "Failed to commit NVS changes");
    } else {
        ESP_LOGI("verifyResetFactory", "WIFI设置重置为enabled: %d, ssid: %s, pass: %s", new_enabled, new_wifi_ssid, new_wifi_password);
    }
    nvs_close(nvs_handle);
    if (wifi_ssid != NULL)
        free(wifi_ssid);
    wifi_ssid = strdup(new_wifi_ssid);
    if (wifi_password != NULL)
        free(wifi_password);
    wifi_password = strdup(new_wifi_password);
    lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    if (new_enabled == 1) {
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        wifi_disconnect();
    }


    // 重置蓝牙配置(虽然这个不操作nvs)
    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_WIFI_STA);
    int combined = (mac[4] % 100) * 100 + (mac[5] % 100); // 将两个字节组合成四位数字
    snprintf(bluetooth_ui_name, sizeof(bluetooth_ui_name), "BT-%04d", combined); // 使用四位数字格式
    lv_textarea_set_text(ui_Bluetooth_Name_Input2, bluetooth_ui_name);
    
    snprintf(bluetooth_ui_pass, sizeof(bluetooth_ui_pass), "%d", 8888);
    lv_textarea_set_text(ui_Bluetooth_Password_Input2, bluetooth_ui_pass);

    xTaskCreate(bluetooth_cfg_task, "bluetooth_cfg_task", 4096, NULL, 5, NULL);
    vTaskDelay(3000 / portTICK_PERIOD_MS);  // 等待蓝牙复位
    ESP_LOGI("verifyResetFactory", "蓝牙设置重置为name: %s, pass: %s", bluetooth_ui_name, bluetooth_ui_pass);


    // 重置时间设置(不操作nvs)
    lv_textarea_set_text(ui_Time_Setting_Hour2, "11");
    lv_textarea_set_text(ui_Time_Setting_Min2, "42");
    lv_textarea_set_text(ui_Date_Setting_Year2, "2022");
    lv_textarea_set_text(ui_Date_Setting_Month2, "04");
    lv_textarea_set_text(ui_Date_Setting_Day2, "13");
    ESP_LOGI("verifyResetFactory", "时间设置重置完成, 这个到底有什么用?");

    // 重置完也把音乐列表clear了, 要把状态和图标改掉
    create_music_item_complete = false;
    lv_obj_clear_flag(ui_tfcard_unavailable_the_X, LV_OBJ_FLAG_HIDDEN);

}
// 不恢复出厂设置
void cancelResetFactory(lv_event_t *e)
{

}
// 曲目刷新
static void track_refresh_task(void *pvParameters) {
    // 清除nvs中的曲目名
    nvs_handle_t nvs_handle;
    esp_err_t err;
    err = nvs_open("filenames", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to open NVS filenames");
        return;
    }
    err = nvs_erase_all(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to erase NVS filenames");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to commit changes in NVS filenames");
    }
    nvs_close(nvs_handle);
    ESP_LOGI("track_refresh_task", "Successfully erased and cleaned NVS filenames");

    // 清除durations
    err = nvs_open("music_durations", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to open NVS music_durations");
        return;
    }
    err = nvs_erase_all(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to erase NVS music_durations");
        nvs_close(nvs_handle);
        return;
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("track_refresh_task", "Failed to commit changes in NVS music_durations");
    }
    nvs_close(nvs_handle);
    ESP_LOGI("track_refresh_task", "Successfully erased and cleaned NVS music_durations");


    // 然后再获得一遍

    // 获得文件名列表写入nvs
    get_all_file_names();
    EventBits_t bits = xEventGroupWaitBits(bt_event_group, EVENT_FILE_LIST_COMPLETE | EVENT_ERROR_ERROR_ERROR, pdTRUE, pdFALSE, portMAX_DELAY);
    if (bits & EVENT_ERROR_ERROR_ERROR) {
        lv_obj_add_flag(ui_TrackRefreshMsgPanel, LV_OBJ_FLAG_HIDDEN);
        lv_label_set_text(ui_PleaseRestartMsgText, "tf卡文件错误");
        lv_obj_clear_flag(ui_PleaseRestartMsgPanel, LV_OBJ_FLAG_HIDDEN);
        xEventGroupSetBits(bt_event_group, EVENT_REFRESH_COMPLETE);
        vTaskDelete(NULL);
    }
    // 获得音乐库的歌的时长写入nvs
    get_all_music_duration();
    xEventGroupWaitBits(bt_event_group, EVENT_ALL_DURATION_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);

    xEventGroupSetBits(bt_event_group, EVENT_REFRESH_COMPLETE);
    vTaskDelete(NULL);
}
void track_refresh(lv_event_t *e) {
    xTaskCreate(track_refresh_task, "track_refresh_task", 8192, NULL, 5, NULL);
    xTaskCreate([](void *param) {
        xEventGroupWaitBits(bt_event_group, EVENT_REFRESH_COMPLETE, pdTRUE, pdFALSE, portMAX_DELAY);
        lv_async_call([](void *param) {
            lv_obj_add_flag(ui_TrackRefreshMsgPanel, LV_OBJ_FLAG_HIDDEN);
            lv_label_set_text(ui_PleaseRestartMsgText, "刷新完成, 3秒后自动重启");
            lv_obj_clear_flag(ui_PleaseRestartMsgPanel, LV_OBJ_FLAG_HIDDEN);
        }, nullptr);
        vTaskDelay(3000 / portTICK_PERIOD_MS);
        esp_restart();
        // vTaskDelete(NULL);
    }, "wait_track_refresh", 2048, NULL, 5, NULL);
}

// ******************** Wifi相关 ********************

// 初始化Wifi名称与密码
void initWifiSettings(lv_event_t *e) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to open NVS: %s", esp_err_to_name(err));
        return;
    }
    // 读取wifi开关状态
    err = nvs_get_u8(nvs_handle, "enabled", &wifi_enabled);
    if (err == ESP_ERR_NVS_NOT_FOUND) {
        wifi_enabled = 0;
        ESP_LOGW("initWifiSettings", "NVS中未找到'enabled', 将写入默认值 %d", wifi_enabled);
        err = nvs_set_u8(nvs_handle, "enabled", wifi_enabled);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set default value for 'enabled': %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_commit(nvs_handle);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to commit 'enabled' to NVS: %s", esp_err_to_name(err));
            nvs_close(nvs_handle);
            return;
        }
    } else if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to get 'enabled' from NVS: %s", esp_err_to_name(err));
    }

    // 读取Wifi名称
    size_t required_size = 0;
    err = nvs_get_str(nvs_handle, "name", NULL, &required_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGE("initWifiSettings", "Failed to get size for name from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    if (required_size > 0) {
        char *tempWifiName = (char *)malloc(required_size);
        if (tempWifiName == NULL) {
            ESP_LOGE("initWifiSettings", "Failed to allocate memory for Wifi name");
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_get_str(nvs_handle, "name", tempWifiName, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to get name from NVS: %s", esp_err_to_name(err));
            free(tempWifiName);
            nvs_close(nvs_handle);
            return;
        }
        wifi_ssid = tempWifiName;
        lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    } else {
        ESP_LOGW("initWifiSettings", "NVS中未找到'name', 将写入默认值 12345678");
        err = nvs_set_str(nvs_handle, "name", "12345678");
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set name in NVS");
            nvs_close(nvs_handle);
            return;
        }
        wifi_ssid = strdup("12345678");
        lv_textarea_set_text(ui_Wifi_SSID_Input, wifi_ssid);
    }

    // 读取Wifi密码
    required_size = 0;
    err = nvs_get_str(nvs_handle, "password", NULL, &required_size);
    if (err != ESP_OK && err != ESP_ERR_NVS_NOT_FOUND) {
        ESP_LOGE("initWifiSettings", "Failed to get size for password from NVS: %s", esp_err_to_name(err));
        nvs_close(nvs_handle);
        return;
    }
    if (required_size > 0) {
        char *tempWifiPassword = (char *)malloc(required_size);
        if (tempWifiPassword == NULL) {
            ESP_LOGE("initWifiSettings", "Failed to allocate memory for Wifi password");
            nvs_close(nvs_handle);
            return;
        }
        err = nvs_get_str(nvs_handle, "password", tempWifiPassword, &required_size);
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to get password from NVS: %s", esp_err_to_name(err));
            free(tempWifiPassword);
            nvs_close(nvs_handle);
            return;
        }
        wifi_password = tempWifiPassword;
        lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    } else {
        ESP_LOGW("initWifiSettings", "NVS中未找到'password', 将写入默认值 12345678");
        err = nvs_set_str(nvs_handle, "password", "12345678");
        if (err != ESP_OK) {
            ESP_LOGE("initWifiSettings", "Failed to set password in NVS");
            nvs_close(nvs_handle);
            return;
        }
        wifi_password = strdup("12345678");
        lv_textarea_set_text(ui_Wifi_Password_Input, wifi_password);
    }
    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("initWifiSettings", "Failed to commit NVS changes");
    }
    nvs_close(nvs_handle);

    if (wifi_enabled == 0) {
        // 如果禁用wifi, 把相关UI禁用后返回
        lv_obj_clear_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        lv_obj_add_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);

        // 连接WiFi并获得时间
        start_wifi_connect_task(wifi_ssid, wifi_password);
    }
}
// 确认保存Wifi名称与密码
void saveWifiSetting(lv_event_t *e) {
    const char *name = lv_textarea_get_text(ui_Wifi_SSID_Input);
    if (name != NULL) {
        if (wifi_ssid != NULL)
            free(wifi_ssid);
        wifi_ssid = strdup(name);
    }
    const char *password = lv_textarea_get_text(ui_Wifi_Password_Input);
    if (password != NULL) {
        if (wifi_password != NULL)
            free(wifi_password);
        wifi_password = strdup(password);
    }

    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("WifiCfg", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to open NVS");
        return;
    }

    wifi_enabled = lv_obj_has_state(ui_Wifi_Switch_Switch2, LV_STATE_CHECKED);
    err = nvs_set_u8(nvs_handle, "enabled", wifi_enabled ? 1 : 0);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set enabled in NVS: %s", esp_err_to_name(err));
    }

    err = nvs_set_str(nvs_handle, "name", name);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set name in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_set_str(nvs_handle, "password", password);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to set password in NVS");
        nvs_close(nvs_handle);
        return;
    }

    err = nvs_commit(nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE("saveWifiSetting", "Failed to commit NVS changes");
    }

    nvs_close(nvs_handle);

    if (wifi_enabled == 1) {
        lv_obj_clear_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        lv_img_set_src(ui_Wifi_States_Icon, &ui_img_236134236);

        start_wifi_connect_task(name, password);
        if (wait_wifi_connect_task_handle != NULL) {
            vTaskDelete(wait_wifi_connect_task_handle);
            wait_wifi_connect_task_handle = NULL;
        }
    } else {
        lv_obj_add_flag(ui_Wifi_States_Icon, LV_OBJ_FLAG_HIDDEN);
        if (wait_wifi_connect_task_handle != NULL) {
            vTaskDelete(wait_wifi_connect_task_handle);
            wait_wifi_connect_task_handle = NULL;
        }
        wifi_disconnect();
    }
}

// ******************** 音乐相关 ********************

// 点击主界面的音乐库按钮时的回调
void attempt_enter_music_window(lv_event_t *e) {
    if (device_state != 2) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "TF卡未插入");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
        lv_timer_resume(close_tf_card_notfound_msg_timer);
    } else if (create_music_item_complete != true) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "未刷新曲目");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
        lv_timer_resume(close_tf_card_notfound_msg_timer);
    } else {
        lv_scr_load(ui_Music_Window);
    }
}
// 更新进度条与时间标签的回调函数
static void update_progress(lv_timer_t *timer) {
    lv_async_call([](void *) {
        if (currentPlayTime < current_music_duration) {
            currentPlayTime++;
            // 更新当前时间标签
            char time_str[9];  // hh:mm:ss
            format_time(currentPlayTime, time_str, sizeof(time_str));
            lv_label_set_text(ui_Current_Time, time_str);

            int progressValue = (currentPlayTime * 100) / (current_music_duration);
            lv_slider_set_value(ui_Progress_Slider, progressValue, LV_ANIM_OFF);
        } else {
            if (progressTimer != NULL) {
                lv_img_set_src(ui_Play_Pause_Icon, &ui_img_2101671624);
                lv_timer_pause(progressTimer);  // 停止定时器
            }
        }
    }, NULL);
}
// 初始化音频进度条定时器
static void initProgressBar(void) {
    // 创建定时器，每秒更新一次
    progressTimer = lv_timer_create(update_progress, 1000, NULL);
    lv_timer_pause(progressTimer);  // 初始化时暂停定时器
}
// 设置新的进度条
static void create_protgress_bar(void) {
    current_music_duration = music_durations[current_playing_index] - 1;    // 将总时长减1秒以更好地...做许多事
    char time_str[12];
    format_time(current_music_duration, time_str, sizeof(time_str));
    ESP_LOGI("create_protgress_bar", "Total time: %s", time_str);
    lv_label_set_text(ui_Total_Time, time_str);

    currentPlayTime = 0;

    lv_timer_reset(progressTimer);  // 重置进度条
    lv_timer_resume(progressTimer); // 然后启动
}
// 关闭EVENT_PLAY_MUSIC_WITH_ID位的任务, AT响应实际上非常快, 但还是会阻塞界面, 不知道有没有必要每次都clear, 也许就不管它而在退出音乐库时clear得了
static void clear_play_event_bit_task(void *pvParameter) {
    xEventGroupClearBits(music_event_group, EVENT_PLAY_MUSIC_WITH_ID);
    vTaskDelete(NULL);
}
// 播放指定index的音乐(file_names里的index)
static void playMusicWithCurrentIndex(void) {
    // 如果浴室在播放, 关掉它
    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
        lv_async_call(hide_bath_sound_icon_callback, NULL);
        ESP_LOGI("close bath play", "已关闭浴室音乐");
    }

    char command[50];
    int id;
    sscanf(file_names[current_playing_index], "%2d", &id);
    // 不用AT_AF(), 因为那会阻塞一瞬间的线程
    snprintf(command, sizeof(command), "AT+AF%02d", id);
    bluetooth_send_at_command(command, CMD_PLAY_MUSIC_WITH_ID);
    xTaskCreate(clear_play_event_bit_task, "clear_play_event_bit_task", 1024, NULL, 2, NULL);

    create_protgress_bar();

    // 在列表中高亮指定的音乐名字
    if (current_playing_music_obj != NULL) {
        lv_obj_clear_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
    }
    current_playing_music_obj = music_obj_list[current_playing_index];
    lv_obj_add_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
    // 保证在列表中, 总是显示当前音乐所在的musicList页
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
    currentListIndex = current_playing_index / MAX_ITEMS_PER_LIST;
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 上一页音乐列表
void prevMusicList(lv_event_t *e) {
    if (numMusicLists == 0) return;
    // 隐藏当前列表
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);

    // 切换到上一个列表
    currentListIndex--;
    if (currentListIndex < 0) {
        currentListIndex = numMusicLists - 1;  // 循环到最后一个列表
    }

    // 显示这个列表
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 下一页音乐列表
void nextMusicList(lv_event_t *e) {
    if (numMusicLists == 0) return;
    // 隐藏当前列表
    lv_obj_add_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);

    // 切换到下一个列表
    currentListIndex++;
    if (currentListIndex >= numMusicLists) {
        currentListIndex = 0;  // 循环到第一个列表
    }

    // 显示这个列表
    lv_obj_clear_flag(musicLists[currentListIndex], LV_OBJ_FLAG_HIDDEN);
}
// 播放Music List中被点击的音乐
void playSelectedMusic(lv_event_t *e) {
    // 在这一步才打开客厅通道
    open_living_room_channel();

    // 更新UI
    changeMusicUpdateUI();
    lv_obj_t *obj = lv_event_get_target(e);
    lv_obj_t *label = lv_obj_get_child(obj, 0);

    char *track_title = lv_label_get_text(label);
    lv_label_set_text(ui_Track_Title, track_title);
    lv_label_set_text(ui_Track_Artist, "null");

    lv_scr_load(ui_Music_Play_Window);

    // 获得当前试图播放的音乐在数组里的索引
    for (int i = 0; i < music_files_count; i++) {
        if (strcmp(track_title, file_names[i] + 2) == 0) {
            current_playing_index = i;
            break;
        }
    }
    printf("INDEX: %d\n", current_playing_index);

    if (play_mode == PLAY_MODE_SHUFFLE) {
        // 重置随机播放的索引
        shufflePlaylist();
        shuffle_list_index = -1;
        for (int i = 0; i < music_files_count; i++) {
            if (shuffle_order[i] == current_playing_index) {
                shuffle_list_index = i;
                break;
            }
        }
        if (shuffle_list_index == -1) {
            ESP_LOGE("shuffle", "错误索引");
        }
    }
    playMusicWithCurrentIndex();
}
// 下一首音乐
void nextTrack(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新, 因为485指令也会调用这几个函数
    lv_async_call([](void *) {
        changeMusicUpdateUI();

        switch (play_mode) {
            case PLAY_MODE_LOOP:
                if (current_playing_index < music_files_count - 1) {
                    current_playing_index++;
                } else {
                    current_playing_index = 0;
                }
                break;
            case PLAY_MODE_SINGLE:
                // 不增加current_playing_index就行了
                break;
            case PLAY_MODE_SHUFFLE:
                if (shuffle_list_index < music_files_count - 1) {
                    shuffle_list_index++;
                } else {
                    shuffle_list_index = 0;
                }
                current_playing_index = shuffle_order[shuffle_list_index];
                break;
        }
        char *track_title;
        track_title = file_names[current_playing_index];
        lv_label_set_text(ui_Track_Title, track_title + 2);
        lv_label_set_text(ui_Track_Artist, "null");
        playMusicWithCurrentIndex();
    }, NULL);
}
void prevTrack(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call([](void *param) {
        changeMusicUpdateUI();
        char *track_title;

        switch (play_mode) {
            case PLAY_MODE_LOOP:
                if (current_playing_index > 0) {
                    current_playing_index--;
                } else {
                    current_playing_index = music_files_count - 1;
                }
                break;
            case PLAY_MODE_SINGLE:
                // 不增加current_playing_index
                break;
            case PLAY_MODE_SHUFFLE:
                if (shuffle_list_index > 0) {
                    shuffle_list_index--;
                } else {
                    shuffle_list_index = music_files_count - 1;
                }
                current_playing_index = shuffle_order[shuffle_list_index];
                break;
        }
        track_title = file_names[current_playing_index];
        lv_label_set_text(ui_Track_Title, track_title + 2);
        lv_label_set_text(ui_Track_Artist, "null");
        playMusicWithCurrentIndex();
    }, NULL);
}
// 播放/暂停
void playPause(lv_event_t *e) {
    // 确保在主线程中执行 UI 更新
    lv_async_call([](void *param) {
        AT_CB();
        // 如果是在播放音乐库音乐就修改UI
        if (music_play_task_handle != NULL) {
            if (playing) {
                // 暂停
                lv_timer_pause(progressTimer);
                lv_img_set_src(ui_Play_Pause_Icon, &ui_img_2101671624);
                printf("暂停\n");
                playing = false;
            } else {
                // 播放
                lv_timer_resume(progressTimer);
                lv_img_set_src(ui_Play_Pause_Icon, &ui_img_899744137);
                printf("播放\n");
                playing = true;
            }
        }
        // 如果在放浴室音乐, 更改主界面上的浴室状态图标
        else if (bath_play_task_handle != NULL) {
            if (playing) {
                lv_obj_add_flag(ui_bath_sound_icon, LV_OBJ_FLAG_HIDDEN);
                playing = false;
            } else {
                lv_obj_clear_flag(ui_bath_sound_icon, LV_OBJ_FLAG_HIDDEN);
                playing = true;
            }
        }
    }, NULL);
}
// 切换播放模式
void changePlayMode(lv_event_t *e) {
    switch (play_mode) {
        case PLAY_MODE_LOOP:
            play_mode = PLAY_MODE_SINGLE;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_1071321554);
            break;
        case PLAY_MODE_SINGLE:
            play_mode = PLAY_MODE_SHUFFLE;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_1311962515);
            // 洗完牌后设置很难描述的索引
            shufflePlaylist();
            shuffle_list_index = -1;
            for (int i = 0; i < music_files_count; i++) {
                if (shuffle_order[i] == current_playing_index) {
                    shuffle_list_index = i;
                    break;
                }
            }
            if (shuffle_list_index == -1) {
                ESP_LOGE("shuffle", "错误索引");
            }
            break;
        case PLAY_MODE_SHUFFLE:
            play_mode = PLAY_MODE_LOOP;
            lv_img_set_src(ui_Play_Mode_Btn, &ui_img_260357382);
            break;
        default:
            play_mode = PLAY_MODE_LOOP;
            ESP_LOGE("changePlayMode", "我为什么又要写这种东西");
            break;
    }
}

// ******************** 均衡器相关 ********************

void select_eq_nature(lv_event_t *e) {
    lv_obj_add_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x228B22), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    
    equalizer_mode = EQ_MODE_NATURE;
    lv_label_set_text(ui_Play_Style_Text, "自然");
    close_music_EQ_Panel(NULL);
    AT_CQ(5);
}
void select_eq_jazz(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x6A5ACD), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_JAZZ;
    lv_label_set_text(ui_Play_Style_Text, "爵士");
    close_music_EQ_Panel(NULL);
    AT_CQ(4);
}
void select_eq_rock(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0xDC143C), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_ROCK;
    lv_label_set_text(ui_Play_Style_Text, "摇滚");
    close_music_EQ_Panel(NULL);
    AT_CQ(1);
}
void select_eq_pop(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0xFF1493), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_POP;
    lv_label_set_text(ui_Play_Style_Text, "流行");
    close_music_EQ_Panel(NULL);
    AT_CQ(2);
}
void select_eq_classical(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0xFFD700), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_CLASSICAL;
    lv_label_set_text(ui_Play_Style_Text, "古典");
    close_music_EQ_Panel(NULL);
    AT_CQ(3);
}
void select_eq_opera(lv_event_t *e) {
    lv_obj_clear_state(ui_Mode_Nature_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Jazz_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Rock_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Pop_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Mode_Classical_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Mode_Opera_Btn, LV_STATE_CHECKED);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn1, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn2, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn3, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn4, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn5, lv_color_hex(0x808080), LV_PART_MAIN | LV_STATE_DEFAULT);
    lv_obj_set_style_bg_color(ui_MusicWindowEQBtn6, lv_color_hex(0x8B0000), LV_PART_MAIN | LV_STATE_DEFAULT);

    equalizer_mode = EQ_MODE_OPERA;
    lv_label_set_text(ui_Play_Style_Text, "歌剧");
    close_music_EQ_Panel(NULL);
    AT_CQ(0);
}
// 打开切换均衡器的窗口
void changePlayStyle(lv_event_t * e)
{
    lv_obj_clear_flag(ui_Music_Window_EQ_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_clear_flag(ui_CloseMusicEQPanelRange, LV_OBJ_FLAG_HIDDEN);
}
// 关闭切换均衡器的窗口
void close_music_EQ_Panel(lv_event_t * e) {
    lv_obj_add_flag(ui_Music_Window_EQ_Panel, LV_OBJ_FLAG_HIDDEN);
    lv_obj_add_flag(ui_CloseMusicEQPanelRange, LV_OBJ_FLAG_HIDDEN);
}
// ******************** 自然之音相关 ********************

// 点击主界面的自然之音按钮时的回调
void attempt_enter_nature_window(lv_event_t *e) {
    if (device_state != 2) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "TF卡未插入");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
        lv_timer_resume(close_tf_card_notfound_msg_timer);
    } else if (create_music_item_complete != true) {
        lv_label_set_text(ui_TFCardNotFoundMsgText, "未刷新曲目");
        lv_obj_clear_flag(ui_TFCardNotFoundMsg, LV_OBJ_FLAG_HIDDEN);
        lv_timer_reset(close_tf_card_notfound_msg_timer);
        lv_timer_resume(close_tf_card_notfound_msg_timer);
    } else {
        lv_scr_load(ui_Nature_Sound_Window);
    }
}
// 重复播放指定自然之音的任务
static void selectNatureSoundTask(void *pvParameter) {
    // 只要开始播放任意一个自然之音, 就删除不活动定时器, 无论如何都不自动返回主界面, 仅能手动返回
    del_inactive_timer();

    while (1) {
        // 如果浴室在播放, 关掉它
        if (bath_play_task_handle != NULL) {
            vTaskDelete(bath_play_task_handle);
            bath_play_task_handle = NULL;
            lv_async_call(hide_bath_sound_icon_callback, NULL);
            ESP_LOGI("selectNatureSoundTask", "已关闭浴室音乐");
        }
        xEventGroupWaitBits(bt_event_group, EVENT_END_PLAY, pdTRUE, pdFALSE, portMAX_DELAY);
        AT_AF(current_nature_id);
    }
}

void selectBirdSound(lv_event_t *e) {
    lv_obj_add_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    current_nature_id = nature_file_ids[0];

    AT_AF(current_nature_id);
    if (nature_play_task_handle == NULL) {
        xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, NULL, 5, &nature_play_task_handle);
    }
}
void selectBugSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    current_nature_id = nature_file_ids[1];
    AT_AF(current_nature_id);
    if (nature_play_task_handle == NULL) {
        xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, NULL, 5, &nature_play_task_handle);
    }
}
void selectForestSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    current_nature_id = nature_file_ids[2];
    AT_AF(current_nature_id);
    if (nature_play_task_handle == NULL) {
        xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, NULL, 5, &nature_play_task_handle);
    }
}
void selectSeaSound(lv_event_t *e) {
    lv_obj_clear_state(ui_Bird_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Bug_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_clear_state(ui_Forest_Sound_Btn, LV_STATE_CHECKED);
    lv_obj_add_state(ui_Sea_Sound_Btn, LV_STATE_CHECKED);

    current_nature_id = nature_file_ids[3];
    AT_AF(current_nature_id);
    if (nature_play_task_handle == NULL) {
        xTaskCreate(selectNatureSoundTask, "selectNatureSoundTask", 4096, NULL, 5, &nature_play_task_handle);
    }
}


// ******************** 闹钟相关 ********************

// 选择铃声
void select_ringtone(lv_event_t *e) {
    lv_obj_t *obj = lv_event_get_target(e);
    // 获得id
    lv_obj_t *label = lv_obj_get_child(obj, 0);
    char *name = lv_label_get_text(label);
    selected_ringtone_index = name[strlen(name) - 1] - '1';

    for (int i = 0; i < ringtone_files_count; i++) {
        lv_obj_t *item = lv_obj_get_child(ui_Ringtone_List, i);
        lv_obj_add_flag(lv_obj_get_child(item, 2), LV_OBJ_FLAG_HIDDEN);
    }
    // 显示被选中的✅
    lv_obj_t *icon = lv_obj_get_child(obj, 2);
    lv_obj_clear_flag(icon, LV_OBJ_FLAG_HIDDEN);
    
    open_living_room_channel();
    // 预览铃声, 音乐模式在进入界面时就开了
    AT_AF(ringtone_file_ids[selected_ringtone_index]);
}
// 退出选择铃声界面时调用
void cancel_preview_ringtone(lv_event_t *e) {
    AT_AA0();
}

// 等滑动完滚筒后, 等一会再更新时间值
static void delay_update_alarm_clock_time_callback(lv_timer_t *timer) {
    lv_async_call([](void *param) {
        lv_label_set_text_fmt(ui_AlarmClockTimeHour, "%02d", alarm_clock_selected_hour);
        lv_label_set_text_fmt(ui_AlarmClockTimeMin, "%02d", alarm_clock_selected_min);

        time_t countdown_time = calculate_timer_length(alarm_clock_selected_hour, alarm_clock_selected_min);
        lv_label_set_text_fmt(ui_alarm_clock_countdown_time_text, "%lld小时%lld分钟后响铃", countdown_time / 3600, (countdown_time % 3600) / 60);

        lv_timer_pause(delay_update_alarm_clock_timer);
    }, NULL);
}
void change_alarm_clock_hour(lv_event_t *e) {
    alarm_clock_selected_hour = lv_roller_get_selected(ui_alarm_clock_hour_roller);
    lv_timer_reset(delay_update_alarm_clock_timer);
    lv_timer_resume(delay_update_alarm_clock_timer);
}
void change_alarm_clock_min(lv_event_t *e) {
    alarm_clock_selected_min = lv_roller_get_selected(ui_alarm_clock_min_roller);
    lv_timer_reset(delay_update_alarm_clock_timer);
    lv_timer_resume(delay_update_alarm_clock_timer);
}

// 让闹钟一直叫
static void alarm_clock_cycle_shout_task(void *param) {
    while (1) {
        xEventGroupWaitBits(bt_event_group, EVENT_END_PLAY, pdTRUE, pdFALSE, portMAX_DELAY);
        AT_AF(ringtone_file_ids[selected_ringtone_index]);
    }
}
// 闹钟响了!
static void alarm_clock_shout_callback(TimerHandle_t xTimer) {
    lv_obj_t *scr = lv_scr_act();

    alarm_clock_ready_shouting = true;
    // 回到主界面
    lv_scr_load(ui_Main_Window);
    // 如果原先在音乐库, 自然之音之类的地方, 那个界面的unloaded都做了clean了, 所以写点不正常的:
    // 如果原先在音乐播放界面, 这里直接跑主界面, 就得做一下clean
    if (scr == ui_Music_Play_Window) {
        vTaskDelete(music_play_task_handle);
        music_play_task_handle = NULL;
        // 关闭当前音乐名高亮
        if (current_playing_music_obj != NULL) {
            lv_obj_clear_state(lv_obj_get_child(current_playing_music_obj, 0), LV_STATE_CHECKED);
            current_playing_music_obj = NULL;
        }
        ESP_LOGI("alarm_clock_shout_callback", "已关闭音乐库播放");
    }
    // 浴室可没有自己的界面
    if (bath_play_task_handle != NULL) {
        vTaskDelete(bath_play_task_handle);
        bath_play_task_handle = NULL;
        lv_async_call(hide_bath_sound_icon_callback, NULL);
        ESP_LOGI("alarm_clock_shout_callback", "已关闭浴室音乐");
    }
    assert(music_play_task_handle == NULL && bath_play_task_handle == NULL && nature_play_task_handle == NULL);

    // 显示出闹钟并大喊大叫
    lv_label_set_text_fmt(ui_shouting_alarm_clock_time, "%d:%d", alarm_clock_hour, alarm_clock_min);
    lv_obj_clear_flag(ui_shouting_alarm_clock, LV_OBJ_FLAG_HIDDEN);
    if (work_mode != 2) {
        AT_CM(2);
    }
    open_living_room_channel();
    vTaskDelay(1000 / portTICK_PERIOD_MS);
    AT_AF(ringtone_file_ids[selected_ringtone_index]);
    // 显然, 闹钟响铃时不能回到待机界面
    del_enter_idle_timer();

    // 打开闹铃循环播放的任务, 天呐
    assert(alarm_clock_cycle_shout_task_handle == NULL);
    xTaskCreate(alarm_clock_cycle_shout_task, "alarm_clock_cycle_shout_task", 2048, NULL, 4, &alarm_clock_cycle_shout_task_handle);

    // 删除闹钟倒计时timer    
    if (xTimerDelete(xTimer, 0) == pdPASS) {
        alarm_clock_itself_timer = NULL;
        printf("已删除闹钟timer\n");
        lv_obj_add_flag(ui_alarm_clock_icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        ESP_LOGE("alarm_clock_shout_callback", "删除闹钟timer失败");
    }
}
// 关闭大喊大叫的闹钟
void close_shouting_alarm_clock(lv_event_t * e) {
    // 关闭逻辑
    AT_CL(0);
    AT_CM(0);
    alarm_clock_ready_shouting = false;
    vTaskDelete(alarm_clock_cycle_shout_task_handle);
    alarm_clock_cycle_shout_task_handle = NULL;
    // 关闭界面
    lv_obj_add_flag(ui_shouting_alarm_clock, LV_OBJ_FLAG_HIDDEN);
    // 恢复待机timer
    create_enter_idle_timer(enter_idle_time_level_to_second(enter_idle_time_level));
}
// 保存闹钟
void save_alarm_clock(lv_event_t *e) {
    alarm_clock_hour = alarm_clock_selected_hour;
    alarm_clock_min = alarm_clock_selected_min;
    time_t timer_length = calculate_timer_length(alarm_clock_hour, alarm_clock_min);

    alarm_clock_enabled = lv_obj_has_state(ui_AlarmClockSwitch, LV_STATE_CHECKED);
    if (alarm_clock_enabled == true) {
        printf("距离响铃需要: %lld秒\n", timer_length);
        // 如果已经设置过闹钟, 删除它再创建新的
        if (alarm_clock_itself_timer != NULL) {
            xTimerDelete(alarm_clock_itself_timer, 0);
            alarm_clock_itself_timer = NULL;
        }
        // 创建并运行闹钟
        alarm_clock_itself_timer = xTimerCreate("alarm_clock", pdMS_TO_TICKS(timer_length * 1000), pdFALSE, NULL, alarm_clock_shout_callback);
        xTimerStart(alarm_clock_itself_timer, 0);
        // 显示图标
        lv_obj_clear_flag(ui_alarm_clock_icon, LV_OBJ_FLAG_HIDDEN);
    } else {
        // 如果已有闹钟, 关掉它
        if (alarm_clock_itself_timer != NULL) {
            printf("已关闭闹钟\n");
            xTimerDelete(alarm_clock_itself_timer, 0);
            alarm_clock_itself_timer = NULL;
            lv_obj_add_flag(ui_alarm_clock_icon, LV_OBJ_FLAG_HIDDEN);
        }
    }
    
}
// 不保存闹钟
void cancel_save_alarm_clock(lv_event_t *e) {
    // 并不用重置选择的时分, 因为进这界面时会自动选择系统时间, 只需要重置switch
    if (alarm_clock_enabled) {
        lv_obj_add_state(ui_AlarmClockSwitch, LV_STATE_CHECKED);
    } else {
        lv_obj_clear_state(ui_AlarmClockSwitch, LV_STATE_CHECKED);
    }
}

// 给485用的
void set_alarm_clock_ready_shouting(bool value) {
    alarm_clock_ready_shouting = value;
}
// ******************** 真的找不到分类 ********************

// 试图进入设置界面
void attempt_enter_settings_window(void) {
    static uint8_t click_count = 0;
    static uint32_t last_click_time = 0;

    uint32_t current_time = lv_tick_get();

    if (current_time - last_click_time > ENTER_SETTINGS_WINDOW_CLICK_RESET_TIME) {
        click_count = 0; // 如果时间间隔超出设定的时间，重置点击计数
    }

    last_click_time = current_time;
    click_count++;

    if (click_count >= ENTER_SETTINGS_WINDOW_CLICK_COUNT) {
        click_count = 0; // 达到点击次数后重置计数
        lv_scr_load(ui_Settings_Window);
    }
}
// 位于主界面的隐藏复位按钮
void attempt_restart_esp32(void) {
    static uint8_t click_count = 0;
    static uint32_t last_click_time = 0;

    uint32_t current_time = lv_tick_get();

    if (current_time - last_click_time > RESTART_ESP32_CLICK_RESET_TIME) {
        click_count = 0; // 如果时间间隔超出设定的时间，重置点击计数
    }

    last_click_time = current_time;
    click_count++;

    if (click_count >= ENTER_SETTINGS_WINDOW_CLICK_COUNT) {
        click_count = 0; // 达到点击次数后重置计数
        bluetooth_send_at_command("AT+CZ", CMD_REBOOT);
        esp_restart();
    }
}

// 位于主界面另一侧的ota按钮
void attempt_ota_esp32(void) {
    static uint8_t click_count = 0;
    static uint32_t last_click_time = 0;

    uint32_t current_time = lv_tick_get();

    if (current_time - last_click_time > RESTART_ESP32_CLICK_RESET_TIME) {
        click_count = 0; // 如果时间间隔超出设定的时间，重置点击计数
    }

    last_click_time = current_time;
    click_count++;

    if (click_count >= ENTER_SETTINGS_WINDOW_CLICK_COUNT) {
        click_count = 0; // 达到点击次数后重置计数
        // xTaskCreate(ota_task, "ota", 8192, NULL, 5, NULL);
    }
}

// 插拔卡时重置一堆设置到默认状态
void reset_a_bunch_settings(void) {
    AT_CA(defaultVolume);
    select_eq_nature(NULL);

    // 闹钟
    lv_async_call([](void *param) {
        lv_obj_clear_state(ui_AlarmClockSwitch, LV_STATE_CHECKED);
        lv_obj_add_flag(ui_shouting_alarm_clock, LV_OBJ_FLAG_HIDDEN);
        lv_obj_add_flag(ui_alarm_clock_icon, LV_OBJ_FLAG_HIDDEN);
    }, nullptr);
    alarm_clock_ready_shouting = false;
    if (alarm_clock_itself_timer != NULL) {
        xTimerDelete(alarm_clock_itself_timer, 0);
        alarm_clock_itself_timer = NULL;
    }
    if (alarm_clock_cycle_shout_task_handle != NULL) {
        vTaskDelete(alarm_clock_cycle_shout_task_handle);
        alarm_clock_cycle_shout_task_handle = NULL;
    }
}

// 进入设置界面时输入密码
void system_password_input(lv_event_t *e) {
    const char *name = lv_textarea_get_text(ui_System_Password_Text);
    if (strlen(name) == 4) {
        if (strcmp(name, "1234") == 0) {
            lv_obj_add_flag(ui_System_Password, LV_OBJ_FLAG_HIDDEN);
        }
    }
}

void set_playing(bool val) {
    playing = val;
}